---
layout: default
title: Inter Process Communication
parent: Inter Process Communication
grand_parent: Micro Service Architecture Pattern
nav_order: 1
---

# Inter Process Communication
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **IPC 개요**


### **클라이언트 / 서비스 상호 작용 스타일**
- 일대일 one-to-one : 각 클라이언트 요청을 정확히 한 서비스가 처리함
- 일대다 one-to-many : 각 클라이언트 요청을 여러 서비스가 협동하여 처리
- 동기 synchronous : 클라이언트는 서비스가 제 시간에 응답하리라 기대하고 대기 도중 블로킹 할 수 있음. 서비스가 서로 강하게 결합됨
- 비동기 asynchronous : 클라이언트가 블로킹하지 않음

<div class="code-example" markdown="1">

| 구분  | 일대일                                                                         | 일대다                                                                   |
|:----------|:-------------------------------------------------------------------------|:-------------------------------------------------------------------|
| 동기   | 요청 / 응답 (request / response)                                               | -                                                                     |
| 비동기 | 비동기 요청 / 응답 (asynchronous request / response), 단방향 알림(one-way notification) | 발행 / 비동기 응답 (publish / async response), 발행 / 구독 (publish / subscribe) |

</div>


### **마이크로서비스 API 정의**
- 서비스 API는 클라이언트가 호출 가능한 작업 과 서비스가 발행하는 이벤트로 구성되는 서비스와 클라이언트 간의 약속
- 작업에는 이름, 매개변수, 반환형이 있고, 이벤트는 타입과 필드를 가지고 메시지 채널에 발행됨
- 인터페이스 정의 언어 IDL 로 서비스 API를 먼저 정의한 후 서비스를 구현해야 함
- API 는 IPC 에 따라 내용이 결정됨 ex. 메시징 통신 API는 메시지 채널, 메시지 타입, 메시지 포맷으로 정의하고 HTTP 통신 API는 URL, HTTP 동사, 요청/응답 포맷으로 구성 


### **API 변경**
- 시맨틱 버저닝 명세 Semvers : 버전 번호를 사용하고 증가시키는 규칙들이 명시된 API 버저닝에 관한 유용한 지침서
  - MAJOR : 하위 호환되지 않는 변경분을 API 에 적용 시 증가
  - MINOR : 하위 호환되는 변경분을 API에 적용 시 증가
  - PATCH : 하위 호환되는 오류 수정 시
- 견고성 원칙 Robustness principle : 가급적 하위 호환성을 보장하는 방향으로 변경해야 함. ex. 요청 속성이 누락되어도 서비스는 기본값을 제공, 서비스가 필요한 것보다 더 많은 속성을 응답하더라도 클라이언트는 무시
- 하위 호환되지 않는 중대한 대규모 변경 시 일정 기간 동안 서비스는 신구 버전 API를 모두 지원해야 함


### **메시지 포맷**
- 메시지 포맷은 IPC 효율, API 사용성, 발전성에 영향을 미침
- 마이크로서비스는 나중에 다른 언어로 작성될 수 있기 때문에 범언어적 메시지 포맷을 선택하는 것이 중요
- 텍스트 메시지 포맷 : JSON, XML 등 사람이 읽을 수 있고 자기 서술적인 텍스트 기반 포맷. 하위 호환성이 쉽게 보장되지만 메시지가 다소 긴 단점이 있음
- 이진 메시지 포맷 : 프로토콜 버퍼, 아브로 등 메시지 구조 정의에 필요한 타입 IDL로 메시지를 직렬화 / 역직렬화하는 코드를 생성하여 사용


* * *


## **동기 원격 프로시저 호출 Remote Procedure Invocation 패턴**


### **RPI 개요**
- 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 요청 / 응답 스타일의 IPC
- 클라이언트의 비즈니스 로직은 RPI 프록시 어댑터 클래스로 구현된 프록시 인터페이스를 호출
- RPI 서버 어댑터 클래스는 서비스 인터페이스를 통해 비즈니스 로직을 호출해서 요청을 처리한 후 응답
- 프록시 인터페이스는 하부 통신 프로토콜을 캡슐화


### **REST 패턴**
- REST는 컴포넌트 상호 작용의 확장성, 인터페이스 일반화, 컴포넌트의 독립적 배포, 상호 작용 지연을 줄이기 위해 중간 컴포넌트, 보안 강화, 레거시 시스템의 캡슐화에 역점을 둔 아키텍처 제약 조건 세트를 제공
- REST는 HTTP 동사를 사용해서 URL로 참조되는 리소스(비즈니스 객체)를 가공함
- REST 성숙도 모델
  - 레벨 0 : 클라이언트는 서비스별로 유일한 URL endpoint 에 HTTP POST 요청을 하여 서비스를 호출. 요청을 할 때마다 액션 및 대상을 지정. 필요한 매개변수도 함께 전달.
  - 레벨 1 : 서비스는 리소스 개념을 지원. 클라이언트는 액션과 매개변수가 지정된 POST 요청을 함.
  - 레벨 2 : 서비스는 HTTP 동사를 이용해서 액션을 수행. 필요 시 매개변수를 지정.
  - 레벨 3 : 서비스를 HATEOAS 원칙에 기반하여 설계. HATEOAS는 GET 요청으로 반환된 리소스 표현형에 그 리소스에 대한 액션의 링크도 함께 태워 보내자는 생각으로 HATEOAS를 사용하면 클라이언트 코드에 URL을 하드 코딩하지 않아도 된다
- 스웨거 Swagger : REST API 를 개발 / 문서화하는 도구 세트. 인터페이스 정의를 기반으로 클라이언트 스텁 stub, 서버 스켈레톤 skeleton 을 생성하는 툴이 포함됨. 오픈 API 명세로 발전되어 REST IDL 로 널리 사용됨
- REST의 장점
  - 단순하고 익숙하다
  - 포스트맨 Postman 이나 curl 등의 도구를 사용해서 간편하게 테스트할 수 있다
  - 요청 / 응답 스타일의 통신을 직접 지원한다
  - 방화벽 친화적이다 (단일 포트를 사용, 인터넷에서 서버 접속이 가능, TCP를 사용)
  - 중간 브로커가 필요하지 않아서 시스템 아키텍처가 단순하다
- REST의 단점
  - 요청 / 응답 스타일의 통신만 지원한다
  - 가용성이 떨어진다 (클라이언트 / 서비스가 모두 실행 중이어야 한다)
  - 서비스 인스턴스의 위치 URL를 클라이언트가 알고 있어야 한다(서비스 디스커버리 매커니즘 필요함)
  - REST 리소스는 비즈니스 객체 중심이어서 요청 한 번으로 연관된 객체를 모두 가져오기 어렵다 (GET /orders/{orderId}?expand=consumer 처럼 쿼리 매개변수로 연관된 객체를 지정할 수 있지만 시나리오가 복잡해지면 효율이 떨어지고 구현 시간이 많이 소요됨)
  - 다양한 업데이트 작업을 HTTP 동사에 매핑하기 어렵다 (POST /orders/{orderId}/cancel 처럼 하위 리소스를 정의해서 사용할 수 있음) 


### **gRPC 패턴**
- 이진 메시지 기반의 프로토콜을 사용하는, 다양한 언어로 클라이언트 / 서버를 작성할 수 있는 프레임워크
- gRPC API는 프로토콜 버퍼 기반의 IDL로 정의하며, 프로토콜 버퍼 컴파일러로 클라이언트 쪽 스텁 및 서버 쪽 스켈레톤을 생성하고 HTTP/2를 통해 메시지를 교환
- gRPC API는 하나 이상의 정적 타입 메서드를 모아놓은 서비스 데피니션과 요청 / 응답 메시지 데피니션으로 구성되고, 단순 요청 / 응답 RPC는 물론 스트리밍 RPC도 지원
- 프로토콜 버퍼 메시지는 각 필드마다 번호가 매겨지고 타입 코드가 할당됨. 메시지 수신자는 자신이 필요한 필드만 추출하므로 하위호환성이 유지됨
- gRPC의 장점
  - 다양한 업데이트 작업이 포함된 API를 설계하기 쉽다
  - 큰 메시지를 교환할 때 콤팩트하고 효율적이다
  - 양방향 스트리밍 덕분에 RPI, 메시징 두 가지 통신 방식 모두 가능하다
  - 다양한 언어로 작성된 클라이언트 / 서버 간 연동이 가능하다
- gRPC의 단점
  - 자바스크립트 클라이언트가 하는 일이 REST/JSON 기반 API보다 많다
  - 구형 방화벽은 HTTP/2를 지원하지 않는다
  - 동기 통신 매커니즘으로 부분 실패 처리가 필요하다


### **회로 차단기 패턴 : 부분 실패 처리**
- 연속 실패 횟수가 주어진 임계치를 초과하면 일정 시간 동안 호출을 즉시 거부하는 RPI 프록시
- 견고한 RPI 프록시 설계
  - 네트워크 타임 아웃 : 응답 대기 중에 항상 타임 아웃을 걸어야 한다
  - 미처리 요청 outstanding request 개수 제한 : 미처리 요청의 최대 개수를 넘는 요청은 즉시 실패 처리
  - 회로 차단기 패턴 : 성공 / 실패 요청 개수를 지켜보다가 에러율이 주어진 임계치를 초과하면 그 이후 시도는 바로 실패 처리
- 불능 서비스 복구 : 에러를 반환하거나 미리 정해진 기본값이나 캐시된 응답 등 대체 값 fallback value 을 반환
- JVM 기반의 넷플릭스 히스트릭스 Netflix Hystrix 라이브러리 나 닷넷 기반의 폴리 Polly 라이브러리로 구현


### **서비스 디스커버리 패턴**
- 서비스 레지스트리 패턴 
  - 애플리케이션 서비스 인스턴스의 네트워크 위치를 DB화한 서비스 레지스트리 service registry 를 사용해서 서비스를 호출하는 방식
  - 서비스 인스턴스가 시작/종료할 때마다 서비스 레지스트리가 업데이트
  - 클라이언트가 서비스를 호출하면 서비스 디스커버리가 서비스 레지스트리에서 가용 서비스 인스턴스 목록을 가져와 그 중 한 서비스로 요청을 라우팅
- 애플리케이션 수준의 서비스 디스커버리 패턴 : 클라이언트/서비스가 서비스 레지스트리와 직접 통신하는 방법
  - 자가 등록 self registration 패턴 : 서비스 인스턴스는 자신의 네트워크 위치를 서비스 레지스트리 등록 API를 호출해서 등록
  - 클라이언트 쪽 디스커버리 패턴 : 클라이언트는 서비스를 호출할 때 먼저 서비스 레지스트리에 있는 가용 서비스 인스턴스 목록을 조회하고 부하 분산하여 요청을 전송
  - 넷플릭스 유레카 Eureka 및 스프링 클라우드 Spring Cloud 프레임워크로 구현
  - 다양한 플랫폼에 서비스가 배포된 경우에도 처리 가능하지만 사용하는 언어에 맞는 서비스 디스커버리 라이브러리가 필요함
- 플랫폼에 내장된 서비스 디스커버리 패턴 : 도커나 쿠버네티스 등 최신 배포 플랫폼이 서비스 등록, 서비스 디스커버리, 요청 라우팅을 전부 관장하는 방법
  - 서드파티 등록 패턴 : 배포 플랫폼의 일부인 등록기 registrar 라는 서드파티 third-party 가 서비스 인스턴스를 서비스 레지스트리에 자동 등록
  - 서버 쪽 디스커버리 패턴 : 클라이언트가 서비스 디스커버리를 담당한 라우터에 DNS명을 요청하면 플랫폼 라우터가 서비스 레지스트리를 쿼리하고 요청을 부하 분산함
  - 서비스 개발 언어와 상관없이 모든 클라이언트 / 서비스에 곧바로 적용 가능하지만 해당 플랫폼으로 배포한 서비스 디스커버리만 지원된다


* * *


## **비동기 메시징 패턴**


### **메시징 개요**
- 메시징은 서비스가 메시지 채널을 통해 메시지를 서로 비동기적으로 주고받는 통신 방식
- 메시지 : 송신된 데이터에 관한 메타데이터 metadata 에 해당하는 키 / 값들로 구성된 헤더 header 와 실제로 송신할 텍스트 또는 이진 포맷의 데이터인 본문 body 으로 이루어짐
  - 문서 document : 데이터만 포함된 제네릭한 메시지 ex. 커맨드에 대한 응답
  - 커맨드 command : RPC 요청과 동등한 메시지. 호출할 작업과 전달할 매개변수가 지정되어 있음
  - 이벤트 event : 송신자에게 어떤 사건이 발생했음을 알리는 메시지. 대부분 도메인 객체의 상태 변화를 나타내는 도메인 이벤트임
- 메시지 채널 : 메시징 인프라를 추상한 것
  - 송신자의 비즈니스 로직은 메시지 송신자 어댑터 클래스로 구현된 송신 포트 인터페이스를 호출하여 메시지 채널을 통해 수신자에게 메시지를 전달
  - 수신자의 메시지 핸들러 handler 어댑터 클래스는 컨슈머 비즈니스 로직으로 구현된 수신 포트 인터페이스를 호출하여 메시지를 처리
  - 송신자가 메시지 채널에 보낼 수 있는 메시지와 수신자가 메시지 채널에서 받을 수 있는 메시지의 개수는 무제한임
  - 점대점 point-to-point 채널 : 채널을 읽는 컨슈머 중 딱 하나만 지정하여 메시지를 전달. 일대일 상호 작용 스타일의 서비스에서 사용. ex. 커맨드 메시지
  - 발행-구독 publish-subscribe 채널 : 같은 채널을 바라보는 모든 컨슈머에 메시지를 전달. 일대다 상호 작용 스타일의 서비스에서 사용. ex. 이벤트 메시지


### ** 메시징 상호 작용 스타일**
- 요청 / 응답 및 비동기 요청 / 응답 
  - 메시징은 원래 성격 자체가 비동기적이라서 비동기 요청 / 응답만 제공하지만 응답을 수신할 때까지 클라이언트를 블로킹 할 수도 있음(실제로 동기 처리 하는 것은 아님)
  - 클라이언트는 수행할 작업과 매개변수가 담긴 커맨드 메시지를 서비스가 소유한 point-to-point 메시징 채널에 보냄
  - 서비스는 요청을 처리한 후 그 결과가 담긴 응답 메시지를 클라이언트가 소유한 point-to-point 채널로 돌려보냄
  - 클라이언트는 MessageId 및 응답 채널을 헤더에 명시하고, 서비스는 MessageId 와 값이 동일한 CorrelationId 가 포함된 응답 메시지를 지정된 응답 채널에 보내면 클라이언트는 요청과 응답 메시지를 맞추어 볼 수 있음 
- 단방향 알림 
  - 서비스가 소유한 point-to-point 채널로 클라이언트가 메시지(커맨드 메시지)를 보내면, 서비스는 이 채널을 구독해서 메시지를 처리(응답을 반환하지 않음)
- 발행 / 구독
  - 클라이언트는 여러 컨슈머가 읽는 발행 / 구독 채널에 메시지를 발행
  - 서비스는 도메인 클래스의 이름을 딴 발행 / 구독 채널을 소유하고, 해당 채널에 도메인 객체의 변경 사실을 알리는 도메인 이벤트를 발행
  - 서비스는 자신이 관심 있는 도메인 객체의 이벤트 채널을 구독
- 발행 / 비동기 응답
  - 발행 / 구독과 요청 / 응답의 엘리먼트를 조합한 고수준의 상호 작용 스타일
  - 클라이언트는 응답 채널 헤더가 명시된 메시지를 발행 / 구독 채널에 발행
  - 컨슈머는 CorrelationId 가 포함된 응답 메시지를 지정된 응답 채널에 보냄
  - 클라이언트는 CorrelationId로 응답을 취합하여 응답 메시지와 요청을 맞추어 봄


### **비동기 API 명세 작성**
- 메시지 채널명, 메시지 타입과 JSON, XML, 프로토콜 버퍼 등 메시지 포맷을 명시
- 비동기 API는 클라이언트가 호출하는 작업과 서비스에 의해 발행되는 이벤트로 나뉜다
- 비동기 작업 명세 작성
  - 요청 / 비동기 응답 스타일 : 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷, 서비스가 반환하는 응답 메시지의 타입과 포맷으로 구성
  - 단방향 알림 스타일 : 서비스의 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지의 타입과 포맷으로 구성
- 발행 이벤트 명세 작성
  - 발행 / 구독 스타일 : 이벤트 채널, 서비스가 채널에 발행하는 이벤트 메시지의 타입과 포맷으로 구성


### **메시지 브로커**
- 브로커리스 메시징 : ZeroMQ 처럼 메시지를 브로커 없이 직접 교환하는 메시징 기술
  - 네트워크 트래픽이 가볍고 지연 시간이 짧다
  - 메시지 브로커가 성능 병목점이나 단일 장애점 Single Point Of Failure 가 될 일이 없다
  - 메시지 브로커를 설정 / 관리 할 필요가 없으므로 운영 복잡도가 낮다
  - 서비스 디스커버리 매커니즘 중 하나를 사용해야 한다
  - 송신자 / 수신자 모두 실행 중이어야 하므로 가용성이 떨어진다
  - 전달 보장 guaranteed delivery 같은 매커니즘을 구현하기가 어렵다
- 브로커 기반 메시징 개요
  - 메시지 브로커는 모든 메시지가 지나가는 중간 지점
  - ActiveMQ, RabbitMQ, Apache Kafka 등
  - 프로그래밍 언어 지원 여부, 메시징 표준 지원 여부, 메시지 순서 유지 여부, 전달 보장 종류, 영속화 여부, 내구성, 확장성, 지연 시간, 경쟁사 컨슈머 지원 여부를 검토하여 애플리케이션 요건에 따라 선택
  - 메시징 순서 유지 및 확장성은 메시지 브로커의 필수 요건
- 메시지 채널
  - JMS 계열(ActiveMQ) : 큐(점대점 채널), 토픽(발행 - 구독 채널)
  - AMQP 계열(RabbitMQ) : 익스체인지 + 큐(점대점 채널), 팬아웃 익스체인지, 컨슈머 개별 큐(발행 - 구독 채널)
  - Apache Kafka : 토픽(점대점 채널, 발행 - 구독 채널)
- 브로커 기반 메시징의 장점
  - 느슨한 결합 : 클라이언트는 적절한 채널에 메시지를 보내는 식으로 요청. 서비스 인스턴스를 몰라도 되므로 디스커버리 매커니즘도 필요 없음
  - 메시지 버퍼링 : 메시지 브로커는 처리 가능한 시점까지 메시지를 버퍼링. 서비스가 느려지거나 불능 상태에 빠지는 사고가 발생해도 클라이언트는 메시지 발행이 가능
  - 유연한 통신 : 모든 상호 작용 스타일을 지원
  - 명시적 IPC : 메시징을 쓰는 원격 서비스와 메시징을 쓰지 않는 로컬 서비스가 분명하게 구분됨
- 메시징의 단점
  - 성능 병목 가능성 : 메시지 브로커가 성능 병목점이 될 위험이 있어서 메시지 브로커의 확장성이 중요함
  - 단일 장애점 가능성 : 메시지 브로커의 가용성이 높아야 함
  - 운영 복잡도 부가 : 메시징 시스템 운영에 따른 복잡도 


### **수신자 확장에 따른 메시지 순서 유지**
- 메시지 순서를 유지한 채 메시지 수신자를 수평 확장 scale-out 하기 위하여 샤딩된 sharded 채널을 이용
- 샤딩된 채널은 복수의 샤드로 구성되며, 각 샤드는 채널처럼 작동
- 송신자는 메시지 헤더에 샤드 키(무작위 문자열 또는 바이트)를 지정하고, 메시지 브로커는 메시지를 샤드 키별로 샤드/파티션에 배정
- 메시징 브로커는 여러 수신자 인스턴스를 묶어 동일한 논리 수신자 처럼 취급하고, 각 샤드를 하나의 수신자에 배정하고, 수신자가 시동/종료하면 샤드를 재배정
- 샤드 키가 동일한 메시지는 각각 동일한 샤드에 발행되고, 어느 한 컨슈머 인스턴스만 메시지를 읽기 때문에 메시지 처리 순서가 보장됨


### **중복 메시지 처리**
- 메시지 브로커는 보통 ‘적어도 한 번 이상’ 메시지를 전달하므로 클라이언트나 네트워크 또는 브로커가 실패할 경우 같은 메시지를 여러 번 전달할 수 있음
- 멱등한 idempotent 메시지 핸들러 작성
  - 멱등하다 : 동일한 입력 값을 반복 호출해도 아무런 부수 효과가 없다 ex. 취소된 주문을 다시 취소하는 경우
  - 단일 메시지 호출은 멱등할 수 있어도 메시지 순서가 유지되지 않으면 문제가 될 수 있다 ex. 주문 생성 후 주문 취소 하였는데 주문 생성이 다시 전송되는 경우 
- 메시지 추적과 중복 메시지 솎아 내기
  - 컨슈머가 메시지 ID를 이용하여 메시지 처리 여부를 추적
  - 컨슈머는 메시지를 처리할 때 비즈니스 엔터티를 생성/수정하는 트랜잭션의 일부로 메시지 ID를 DB 테이블에 기록
  - 중복된 메시지라면 INSERT 쿼리가 실패하고 메시지가 중복 처리 되지 않는다


### **트랜잭셔널 메시징 패턴**
- 서비스는 DB 업데이트 트랜잭션의 일부로 메시지를 발행해야 DB 업데이트 후 메시지 발행 전에 서비스가 중단되어도 문제가 생기지 않는다
- 트랜잭셔널 아웃박스 패턴 : 이벤트나 메시지를 DB에 있는 아웃박스 OUTBOX 에 저장해서 DB 트랜잭션의 일부로 발행한다
  - 메시지를 보내는 서비스는 비즈니스 객체를 생성, 수정, 삭제하는 DB 트랜잭션의 일부로 아웃박스 테이블에 메시지를 삽입한다
  - 메시지 릴레이 relay 는 아웃박스 테이블을 읽어 메시지 브로커에 메시지를 발행한다
  - 메시지를 DB에서 메시지 브로커로 옮기는 방법은 폴링 발행기 패턴과 트랜잭션 로그 테일링 패턴이 있음
- 폴링 발행기 패턴 : DB에 있는 아웃박스를 폴링해서 메시지를 발행한다
  - 메시지 릴레이는 아웃박스 테이블을 폴링해서 미발행 메시지를 조회한다
  - 메시지 릴레이는 조회한 메시지를 메시지 브로커에 발행하고 아웃박스 테이블에서 삭제한다
  - 규모가 작을 경우 쓸 수 있는 방법으로 DB 폴링 비용이 유발된다
- 트랜잭션 로그 테일링 패턴 : 트랜잭션 로그를 테일링하여 DB에 반영된 변경분을 발행한다
  - 트랜잭션 로그 마이너는 DB 트랜잭션 로그(커밋 로그)를 테일링해서 트랜잭션 로그를 읽는다
  - 트랜잭션 로그 마이너는 아웃박스 테이블에 삽입된 메시지에 대응되는 로그 항목을 메시지로 전환하여 메시지 브로커에 발행한다
  - 트랜잭션 로그 테일링을 구현한 디비지움 Debezium 프로젝트, 링크드인 데이터버스 LinkedIn Databus 프로젝트, DynamoDB 스트림즈, 이벤추에이트 트램 프로젝트 등이 있음


**cf.이벤추에이트 트램 프레임워크**
- 기초 메시징 API
  - MessageProducer 인터페이스 : 프로듀서 서비스는 메시지를 메시지 채널에 발행
  - MessageConsumer 인터페이스 : 컨슈머 서비스는 메시지 채널에서 메시지를 구독
- 도메인 이벤트 발행 / 구독 API
  - 도메인 이벤트 : 비즈니스 객체를 생성, 수정, 삭제 시 애그리거트(비즈니스 객체)가 발생시킨 이벤트
  - DomainEventPublisher 인터페이스 : 서비스는 도메인 이벤트 채널에 도메인 이벤트를 발행
  - DomainEventDispatcher 클래스 : 서비스는 DomainEventHandlers로  도메인 이벤트를 소비
- 커맨드 / 응답 메시징 API
  - CommandProducer 인터페이스 : 클라이언트는 커맨드 메시지를 서비스에 보냄
  - CommandDispatcher 클래스 : 서비스는 CommandHandlers로 커맨드 메시지를 소비


* * *


## **가용성 개선**


### **동기 통신의 가용성 저하**
- 동기 통신 프로토콜은 호출한 서비스가 응답할 때까지 클라이언트가 기다려야 하므로 가용성이 떨어진다
- 시스템 작업의 가용성은 그 작업이 호출한 서비스의 가용성을 모두 곱한 값이므로, 더 많은 서비스가 요청 처리에 개입할수록 가용성은 더욱 낮아진다


### **동기 상호 작용 제거**
- 비동기 상호 작용 스타일 : 클라이언트 / 서비스가 메시징 채널을 통해 메시지를 전송해서 서로 비동기 통신하면 어느 쪽도 응답을 대기하며 블로킹되지 않는다
- 데이터 복제 
  - 서비스 요청 처리에 필요한 다른 서비스의 데이터의 레플리카를 유지해서 다른 서비스와 상호 작용하지 않는 방법
  - 데이터 레플리카는 데이터를 소유한 서비스가 발행하는 이벤트를 구독해서 최신 데이터를 유지
  - 대용량 데이터의 레플리카를 만드는 것은 비효율적임
- 응답 반환 후 마무리
  - 클라이언트 요청 처리 중 다른 서비스와 동기적 상호 작용을 하지 않고 메시지를 비동기 전송하여 서비스를 느슨하게 결합시키는 방법
  - 서비스는 로컬에서 가용한 데이터만 갖고 요청을 검증하고, 메시지를 OUTBOX 테이블에 삽입하는 식으로 DB를 업데이트 한 다음 클라이언트에 응답을 반환
  - 추후 다른 서비스와 비동기 통신한 메시지를 바탕으로 요청 상태를 변경하여 완료함
  - 다른 서비스가 내려가는 사고가 발생하더라도 계속 클라이언트에 응답할 수 있음
  - 요청을 완전히 처리하기 전에 클라이언트에 응답하는 서비스는 요청이 완료되었는지 확인하기 위하여 클라이언트가 주기적으로 폴링하거나 서비스가 알림 메시지를 보내주어야 하므로 클라이언트 코드가 조금 복잡해짐