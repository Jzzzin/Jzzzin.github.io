---
layout: default
title: Integration Test
parent: Micro Service Test
grand_parent: Micro Service Architecture Pattern
nav_order: 2
---

# Integration Test
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **통합 테스트**


### **통합 테스트 개요**
- 인프라 서비스, 타 애플리케이션 서비스와 적절히 연동되는지 확인하는 테스트
- 서비스를 통째로 테스트하지 않고 통신 기능이 구현된 어댑터 클래스와 그 어댑터의 지원 클래스를 테스트한다
- 계약을 활용하여 테스트를 간소화한다
  - 계약은 두 서비스 간 상호 작용의 구체적인 사례로, 서비스 간 상호 작용의 종류마다 구조가 다르다
  - 발행 / 구독형 상호 작용인 경우 도메인 이벤트 메시지 1개, 요청 / 응답 및 비동기 요청 / 응답형 상호 작용인 경우 HTTP 요청 / 응답 메시지 2개 또는 커맨드 메시지 및 응답 메시지 2개로 구성된다
  - 계약의 용도 : 컨슈머 / 프로바이더 둘 다 테스트해서 서로 바라보는 API가 일치하는가 확인하는 것
- 컨슈머 쪽 테스트 
  - 컨슈머의 어댑터에 대한 테스트
  - 계약을 이용하여 프로바이더를 모킹한 스텁을 구성할 수 있어서 프로바이더를 실행할 필요 없이 컨슈머 통합 테스트를 작성할 수 있다
- 프로바이더 쪽 테스트
  - 프로바이더의 어댑터에 대한 테스트
  - 어댑터의 디펜던시를 목으로 잡아 놓고 계약을 이용하여 어댑터를 테스트한다
- 통합 테스트는 서비스가 자신의 클라이언트 / 디펜던시와 올바르게 소통하는지, 단위 테스트는 서비스 로직이 정확한지 확인하지만, 전체 서비스를 실행하지는 않기 때문에 전체 서비스가 잘 작동되는지 확인하려면 컴포넌트 테스트가 필요하다


### **영속화 테스트**
- DB에 데이터를 저장하는 서비스의 DB 접근 로직이 잘 동작하는지 확인하는 테스트
- DB 프로비저닝 provisioning
  - 프로비저닝 : 사용자의 요구에 맞게 시스템 자원을 할당, 배치, 배포해 두었다가 필요 시 시스템을 즉시 사용할 수 있는 상태로 미리 준비해 두는 것
  - 도커를 활용하여 도커 컴포즈 그레이들 Docker Compose Gradle 플러그인으로 영속화 통합 테스트를 하는 동안 DB를 실행한다
- 테스트 순서
  - 설정 setup : DB 스키마를 생성하고 기지 known 의 상태로 초기화하는 DB를 설정한다. DB 트랜잭션을 시작하기도 한다
  - 실행 execute : DB 작업을 수행한다
  - 확인 verify : DB 상태, DB에서 조회한 객체를 단언한다
  - 정리 teardown : 설정 단계에서 시작한 트랜잭션을 롤백하는 등 DB에 변경한 내용을 언두해야 할 경우 필요하다
  - cf. JPA 기술로 DB 스키마를 생성하는 것 외에 DB 상태에 대해 어떤 가정도 하지 않으면 DB에 변경한 내용을 롤백할 필요가 없고, 메모리에 데이터 변경분이 캐시되는 ORM 특유의 문제도 막을 수 있다


### **REST 요청 / 응답형 상호 작용 테스트**
- REST 클라이언트 / 서비스는 REST endpoint 및 요청 / 응답 본문의 구조에 대해 합의해야 하므로 HTTP 요청 / 응답으로 구성된 계약들로 기술한 컨슈머 주도 계약 테스트를 사용한다
- REST API 계약
  - 클라이언트가 전송하는 HTTP 요청과 서버가 반환하리라 기대되는 HTTP 응답을 지정
  - 계약의 요청 : HTTP 메서드, 경로, 헤더(옵션)
  - 계약의 응답 : HTTP 상태코드, 헤더(옵션), 본문(해당 시)
- 컨슈머 쪽 통합 테스트
  - 스프링 클라우드 컨트랙트가 계약을 이용하여 프로바이더 서비스의 동작을 흉내낸 HTTP 스텁 서버를 구성한다
  - 테스트 클래스에 @AutoConfigureStubRunner 애너테이션을 붙이면 스프링 클라우드 컨트랙트가 랜덤 포트에 와이어목 서버를 계약 내용대로 구성 / 실행한다
  - 테스트 메서드는 컨슈머 서비스 프록시가 프로바이더 서비스를 올바르게 호출했는지 확인한다
- 프로바이더 쪽 통합 테스트
  - 스프링 클라우드 컨트랙트는 계약을 이용하여 테스트를 코드-생성 code-generate 한다
  - 테스트 클래스의 추상 기초 클래스는 테스트 설정 단계를 담당하며 목 디펜던시가 주입된 컨트롤러를 생성하고, 이 목이 컨트롤러가 기대한 응답을 만들어 내도록 설정한다
  - 테스트는 REST API endpoint 가 Controller 에 제대로 구현되어 클라이언트의 기대에 부합하는지 확인한다


### **발행 / 구독 스타일 상호 작용 테스트**
- 다수의 타 서비스가 소비하는 도메인 이벤트를 발행하는 서비스는 발행기 / 컨슈머가 바라보는 메시지 채널 및 도메인 이벤트 구조가 서로 일치하는지 확인하는 통합테스트를 해야 한다
- 발행 / 구독 상호 작용 테스트는 REST 상호 작용 테스트처럼 상호 작용을 계약 세트로 정의하지만, 각 계약마다 도메인 이벤트를 지정하는 차이점이 있다
- 이벤트 발행 계약
  - 이벤트의 채널, 기대되는 본문 및 메시지 헤더를 명시
  - label : 컨슈머 테스트에서 스프링 컨트랙트가 이벤트 발행을 트리거하기 위해 사용하는 엘리먼트
  - triggeredBy : 코드-생성된 테스트 메서드가 이벤트 발행을 트리거하기 위해 호출하는 상위 클래스의 메서드명
- 컨슈머 쪽 테스트
  - 테스트 클래스는 목 디펜던시가 주입된 EventHandler 를 생성한다
  - 테스트 메서드는 스프링 클라우드를 호출해서 계약에 명시된 이벤트를 발행하고, EventHandler가 목 디펜던시를 올바르게 호출하여 계약대로 이벤트를 소비하는지 확인한다
- 프로바이더 쪽 테스트
  - 스프링 클라우드 컨트랙트는 테스트를 코드-생성한다
  - 테스트 클래스의 기초 클래스는 EventPublisher 가 인-메모리 메시징 스텁을 사용하도록 구성하고, 코드-생성된 테스트 메서드가 이벤트 발행을 트리거하기 위해 호출하는 훅 메서드 hook method 를 정의한다 
  - 테스트 메서드는 훅 메서드를 호출하여 EventPublisher가 계약대로 기대되는 이벤트를 발행하는지 확인한다


### **비동기 요청/응답 상호 작용 테스트**
- 커맨드를 전송하는 서비스인 요청자 requestor 와 커맨드 처리 후 응답을 반환하는 서비스인 응답자 replier가 바라보는 커맨드 메시지 채널명과 커맨드 / 응답 메시지의 구조는 반드시 일치해야 한다
- 비동기 요청 / 응답 상호 작용 테스트는 REST 상호 작용 테스트처럼 상호 작용을 계약 세트로 정의하지만, 계약에 HTTP 요청 / 응답 대신 입출력 메시지를 지정한다
- 비동기 요청 / 응답 계약
  - 입력 메시지와 출력 메시지 모두 메시지 채널, 본문, 헤더가 지정되어 있다
  - messageFormat : 메시지를 읽을 채널로 입력 메시지에 지정
  - sentTo : 응답을 전송할 채널로 출력 메시지에 지정
- 컨슈머 쪽 테스트
  - 스프링 클라우드 컨트랙트는 메시징 스텁을 구성하여 입력 메시지와 커맨드 메시지가 일치하는 계약을 찾아내 그 출력 메시지를 응답으로 전송한다
  - 테스트 메서드는 커맨드 메시지 프록시 클래스가 계약대로 커맨드 메시지를 전송하고 응답 메시지를 올바르게 처리하는지 확인한다
- 프로바이더 쪽 테스트 
  - 스프링 클라우드 컨트랙트는 계약별 테스트 메서드를 갖고 있는 테스트 클래스를 코드-생성한다
  - 테스트 클래스의 기초 클래스는 목 디펜던시가 주입된 CommandHandler를 생성한다
  - 테스트 메서드는 계약의 입력 메시지를 커맨드 메시지로 전송하고 그 응답 메시지가 계약의 출력메시지와 일치하는지 확인한다 


* * *


## **컴포넌트 테스트**


### **컴포넌트 테스트 개요**
- 서비스에 대한 인수 테스트로 서비스 디펜던시를 스터빙하여 서비스만 따로 테스트한다
- 종단 간 테스트에 비해 작성하기 쉽고 실행 속도가 빠르다 


### **인수 테스트**
- 소프트웨어 컴포넌트의 비즈니스와 연관된 테스트로 사용자 스토리나 유스 케이스에서 출발하며, 클라이언트의 관점에서 어떤 동작이 외부에 드러나야 하는지 시나리오로 기술하여 도출한다
- given ~ 라면 : 설정 단계 setup phase
- when ~ 경우 : 실행 단계 execute phase
- then ~ 되어야 한다 / and 그리고 : 확인 단계 verification phase


### **거킨을 이용한 인수 테스트 작성**
- 거킨 Gherkin 
  - 실행 가능한 명세를 작성하는 테스트 DSL
  - 일상 언어로 작성한 시나리오 형태로 인수 테스트를 정의한 후, 큐컴버 Cucumber 라는 거킨 전용 테스트 자동화 프레임워크를 이용하여 명세를 실행
  - 시나리오를 실행 가능한 코드로 전환
- 피처 feature
  - 거킨 명세를 구성하는 기능 / 특성으로 여러 시나리오로 기술한다
  - 명칭 : 피처명
  - 명세 개요 : 피처가 존재하는 이유(사용자 스토리)를 기술
  - 시나리오 : given-when-then 구조를 가지며 선행 조건 precondition, 액션 또는 발생한 이벤트, 기대되는 결과를 기술
- 큐컴버 Cucumber
  - 거킨으로 작성한 테스트를 실행하는 자동화 테스트 프레임워크로 자바를 비롯한 다양한 언어를 지원
  - given, then, when 스텝을 정의한 메서드로 구성된 스텝 데피니션 클래스를 생성하여 거킨 시나리오를 실행
  - @Given : 설정 단계를 나타내는 스텝 데피니션 메서드 애너테이션
  - @When : 실행 단계를 나타내는 스텝 데피니션 메서드 애너테이션
  - @Then, @And : 확인 단계를 나타내는 스텝 데피니션 메서드 애너테이션 


### **컴포넌트 테스트 분류**
- 컴포넌트 테스트가 거킨 시나리오를 실행하려면 여러 서비스의 스텁을 설정해야 하고, DB, 메시징 인프라를 구성해야 함
- 인-프로세스 컴포넌트 테스트 in-process component test
  - 인-메모리 스텁과 목 디펜던시로 서비스를 실행하는 테스트
  - ex. 스프링 부트 테스트 프레임워크로 스프링 부트 기반 서비스의 컴포넌트 테스트를 작성
  - 작성하기 간단하고 빨리 실행되지만, 배포 가능한 서비스를 테스트할 수 없는 단점이 있음
- 아웃-오프-프로세스 컴포넌트 테스트 out-of-process component test
  - 서비스를 프로덕션 레디 포맷으로 묶어 별도의 프로세스로 실행하는 테스트
  - DB, 메시지 브로커 등은 실제 인프라 서비스를 사용하고, 애플리케이션 서비스 형태의 디펜던시는 스텁으로 대신함
  - 테스트 커버리지가 향상되지만 작성하기 복잡하고, 실행이 느리다
- 아웃-오브-프로세스 테스트는 스텁이 요청 처리 및 응답 반환을 대신하도록 디펜던시에 스텁을 구성해야 한다
  - 통합 테스트와 달리 컨슈머 계약을 테스트하는 것이 주 관심사 이므로 스프링 클라우드 컨트랙트를 사용하는 것은 다소 무겁고 스텁을 테스트 내부에 구성하는 것이 훨씬 간단하다 


### **컴포넌트 테스트 작성**
- 큐컴버 테스트 프레임워크를 이용하여 거킨 인수 테스트 DSL로 작성한 테스트 시나리오를 실행
- ComponentTest 클래스
  - 큐컴버를 실행하는 테스트 클래스
  - @RunWith(Cucumber.class) : JUnit에 큐컴버 테스트 러너를 사용하도록 지시
  - @CucumberOption : 거킨 피처 파일의 경로를 지정
  - 거킨 피처를 읽어 테스트를 정의하고 ComponentTestStepDefinitions 클래스로 실행 가능한 테스트를 만들기 때문에 별도의 테스트 메서드가 없다
- ComponentTestStepDefinitions 클래스
  - 컴포넌트 테스트에서 각 스텝의 의미를 정의한 클래스
  - @ContextConfiguration : 스프링 테스트 프레임워크 애너테이션으로 스프링 ApplicationContext 를 가져와 다양한 스프링 컴포넌트를 정의
  - SagaParticipantStubManager 클래스 : 사가 참여자를 스텁으로 구성하는 테스트 헬퍼 클래스
  - @Given : 서비스 스텁을 구성하는 단계
  - @When : 서비스를 실행하고 후속 스텝을 검증하기 위해 응답을 저장하는 단계
  - @Then : 서비스가 성공했는지 기대되는 상태인지 확인하는 단계
  - @And : 도메인 이벤트가 기대대로 발행되었는지 확인하는 단계
  - MassageTracker : 테스트 도중 발행된 이벤트를 기록하는 테스트 헬퍼 클래스  
- 컴포넌트 테스트 실행
  - 도커를 이용하여 메시지 브로커, DB 등의 인프라 서비스와 더불어 서비스 인스턴스를 실행 후 테스트
  - 도커 컨테이너 Docker container : 서비스 인스턴스를 격리된 샌드박스 내부에 배포할 수 있는 경량급 OS 가상화 메커니즘
  - 도커 컴포즈 Docker Compose : 다수의 컨테이너를 정의하고 한 단위로 묶어 시동 / 중지시킬 수 있는 툴
  - 도커 이미지에 필요한 JAR 파일이 먼저 빌드되도록 컴포넌트 테스트 의존성을 구성하고, 컴포넌트 테스트 직전에 그레이들 도커 컴포즈 플러그인을 실행하고 서비스를 인프라 서비스와 함께 시동


* * *


## **종단 간 테스트**


### **종단 간 테스트 개요**
- 서비스 그룹 또는 전체 애플리케이션을 대상으로 하는 테스트로 가능한 한 적게 사용해야 함
- 가동부가 많고 수많은 서비스와 관련 인프라 서비스까지 함께 배포해야 하므로 느리고, 서비스 중 하나라도 배포 실패하면 무용지물이므로 취약하고, 개발 소요 시간이 길기 때문에 가능하다면 수를 줄이는 것이 좋다


### **종단 간 테스트 설계**
- 사용자 탐험 테스트 user journey test
  - 사용자가 시스템을 돌아다니면서 여기저기 둘러보는 행위를 코드로 구현한 것
  - 각 기능을 따로따로 테스트하는 대신 기능을 모두 수행하는 테스트를 작성하여 작성해야 할 테스트를 줄이고 테스트 실행 시간을 단축시킨다


### **종단 간 테스트 작성**
- 비즈니스와 관련된 테스트이므로 업무 담당자가 이해할 수 있는 고수준의 DSL로 작성
- 거킨으로 테스트를 작성해서 큐컴버로 실행


### **종단 간 테스트 실행**
- 필수 인프라 서비스 등 전체 애플리케이션을 실행해야 하므로 그레이들 도커 컴포즈 플러그인을 이용
- 도커 컴포즈 파일로 하나의 애플리케이션 서비스 대신 모든 애플리케이션 서비스를 실행
- 대규모 시스템의 경우 테스트 개수도 엄청나게 많고 실행이 끝나려면 며칠이 걸릴 수도 있으므로 하위 단계의 테스트 위주로 작성하는 것이 최선

