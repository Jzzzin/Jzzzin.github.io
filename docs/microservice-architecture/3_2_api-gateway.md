---
layout: default
title: API Gateway
parent: Inter Process Communication
grand_parent: Micro Service Architecture Pattern
nav_order: 2
---

# API Gateway
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **외부 API 설계 이슈**


### **서비스 API를 소비하는 클라이언트의 종류**
- 브라우저 기반의 UI 가 구현된 웹 애플리케이션 : 브라우저에서 HTTP 요청을 받아 HTML 페이지를 반환하며, 방화벽 내부에서 실행되고 LAN을 통해 서비스에 접근한다
- 브라우저에서 실행 중인 자바스크립트 애플리케이션 : 방화벽 외부의 브라우저에서 서비스 API를 직접 호출해서 페이지를 동적 리프레시한다
- 모바일 앱 : 방화벽 외부에서 서비스 API를 직접 호출한다
- 서드파티 애플리케이션 : 인터넷을 통해서 API에 접속하며 안정된 API를 필요로 한다


### **모바일 클라이언트가 직접 서비스 API를 호출하는 경우의 문제점**
- 여러 서비스 API에서 데이터를 가져오기 위해 클라이언트가 요청을 여러 번 전송하는 경우 효율이 떨어지고 UX 가 나빠진다
- 캡슐화 되지 않아 서비스 API를 변경하게 되면 모바일 앱도 변경해야 되서 새 버전 출시에 시간이 오래 걸리고 사용자가 앱을 업그레이드 해야 한다
- 방화벽 외부 클라이언트가 사용하기에 불편한 gRPC 기반 서비스나 AMQP 같은 메시징 프로토콜을 서비스API로 사용하는 것이 힘들다


### **다른 클라이언트의 경우**
- 웹 애플리케이션 : 방화벽 내부에 있어 네트워크 대역폭과 지연 시간 문제가 없고, 방화벽에 비친화적인 프로토콜도 사용 가능하며 백엔드 서비스 변경 시에도 함께 수정 가능하다
- 자바스크립트 애플리케이션 : 서비스 API 변경 시 업데이트는 쉽지만 네트워크 지연 문제는 발생하고, 모바일 앱보다 많은 정보를 보여줘야 하는 경우가 많기 때문에 더 많은 서비스 API를 요청해야 할 필요가 있다
- 서드파티 애플리케이션 : API 변경이 힘들기 때문에 구 버전을 오랫동안 유지해야 하는 경우가 흔하고 장기간 하위 호환성을 유지해야 한다


* * *


## **API 게이트웨이 패턴**


### **API 게이트웨이 패턴**
- 마이크로서비스 애플리케이션에 외부 API 클라이언트의 진입점에 해당하는 서비스를 구현하는 방식


### **API 게이트웨이의 주요 기능**
- 요청 라우팅 : HTTP 메서드와 서비스의 HTTP URL을 매핑한 라우팅 맵 routing map 을 이용해 요청을 어느 서비스를 보낼지 결정하는 일종의 리버스 프록시 reverse proxy 기능
- API 조합 : 모바일 클라이언트가 요청 한 번으로 필요한 데이터를 조회할 수 있도록 대단위 coarse-grained API를 제공
- 프로토콜 변환 protocol translation : 필요에 따라 애플리케이션 내부에서 REST 와 gRPC를 혼용할 경우에도 외부 클라이언트에는 REST API를 제공


### **API 게이트웨이의 엣지 edge (주변) 기능**
- 인증 authentication : 요청한 클라이언트의 신원을 확인
- 인가 authorization : 특정 작업을 수행하도록 허가받은 클라이언트인지 확인
- 사용량 제한 rate limiting : 특정(또는 전체) 클라이언트의 초당 요청 개수를 제한
- 캐싱 caching : 서비스 요청 횟수를 줄이고자 응답을 캐시
- 지표 수집 metrics collection : 과금 분석용 API 사용 지표 수집
- 요청 로깅 : 요청을 기록
- 전용 엣지 서비스 dedicated edge service 를 사용하되 지연시간을 줄이기 위해 몇몇 기능은 API 게이트웨이에 구현하는 방법을 사용한다


### **API 게이트웨이의 장단점**
- 애플리케이션의 내부 구조가 캡슐화되어 클라이언트-애플리케이션 간 왕복 횟수가 줄고 클라이언트 코드가 단순해진다
- 개발, 배포, 관리가 필요한 고가용 컴포넌트가 하나 더 늘어난다
- API 게이트웨이가 개발 병목 지점이 될 우려가 있다 (필요 시 BFF 패턴을 이용하여 팀별로 API를 독립적으로 개발 / 배포해야 함)


* * *


## **API 게이트웨이 아키텍처**


### **API 게이트웨이 아키텍처 개요**
- API 계층 : 독립적인 하나 이상의 API 모듈이 있고, 각 API 모듈에는 특정 클라이언트용 API가 구현된다
- 공통 계층 : 엣지 기능 등의 공통 기능이 구현된다
- 클라이언트마다 요건이 천차만별이므로 API 계층에서 각 클라이언트에 맞춤 API를 제공하는 API 모듈을 각각 구현한다
- API 모듈은 서비스 API 하나에 직접 매핑되는 단순한 API 작업은 해당하는 각각의 서비스 API로 요청을 보내고, API를 조합하는 복잡한 API 작업은 사용자 정의 코드로 구현한다


### **API 게이트웨이 소유권 모델**
- API 게이트웨이 전담 팀이 모든 API 게이트웨이를 소유하는 경우 중앙에서 병목 현상이 발생할 수 있어 느슨하게 결합된 자율팀이 되지 않는다
- API 게이트웨이 팀은 공통 모듈 개발 및 게이트웨이 운영 이슈에 집중하고 API 모듈은 해당 클라이언트 팀이 소유하는 구조가 바람직함
- API를 변경할 일이 생기면 해당 클라이언트 팀이 변경된 소스를 API 게이트웨이 소스 리포지터리에 체크인하고, API 게이트웨이 배포 파이프라인을 완전히 자동화하여 자동으로 배포되도록 해야한다
- 여러 팀 사람들이 동일한 코드베이스에 소스를 커밋하기 때문에 책임 소재가 불분명해지는 문제가 생길 수 있다


### **프런트엔드를 위한 백엔드 Backends For Frontends 패턴**
- 각 클라이언트 종류마다 API 게이트웨이를 따로 구현하는 방식
- 각 API 모듈이 하나의 클라이언트 팀이 개발 / 운영하는 스탠드얼론 API 게이트웨이가 되고, API 게이트웨이 팀은 공통 계층을 소유한다
- 공통 기능 코드 중복을 막기 위해 모든 API 게이트웨이에 동일한 기술 스택을 적용하는 것이 좋고, 공통 기능은 API 게이트웨이 팀이 공유 라이브러리로 개발한다
- API 모듈이 격리되어 신뢰성이 향상되고, 관측성 및 확장성이 좋아지며 시동 시간이 단축되는 장점이 있다


### **API 게이트웨이 BFF 패턴 사례 : 넷플릭스**
- 기기별 API가 따로 구현된 API 게이트웨이를 사용하며, API 구현 코드는 클라이언트 기기 팀이 소유 / 개발
- 각 API 모듈은 자체 docker 컨테이너로 실행되고 넷플릭스 팔코 Netflix Falcor 를 이용하여 서비스 API를 표출한 부차 second API 게이트웨이를 호출
- 넷플릭스 팔코는 선언적으로 API를 동적 조합하는 API 기술로 클라이언트는 요청 한 번으로 여러 서비스를 호출할 수 있음
- API 모듈은 서로 분리되어 신뢰성 / 관측성이 향상되고 독립적으로 확장할 수 있음


* * *


## **API 게이트웨이 설계 이슈**


### **성능과 확장성**
- 동기 I / O 모델 
  - 각 네트워크 접속마다 스레드를 하나씩 배정하는 방식
  - 간단하고 잘 작동된다. ex. 자바 EE 서블릿 프레임워크 
  - 다소 무거운 OS 스레드를 사용하기 때문에 스레드 개수에 제약을 받고 동시 접속 가능 개수도 제한적임
- 비동기(논블로킹) I / O 모델
  - 단일 이벤트 루프 스레드가 I / O 요청을 각 이벤트 핸들러로 디스패치하는 방식
  - 네티 Netty, 버텍스 Vertx, 제이보스 언더토우 JBoss Undertow 등 JVM 프레임워크와 Node.js 플랫폼 등이 있음
  - 다중 스레드를 사용하는 오버헤드가 없기 때문에 확장성이 좋다
  - 비동기 / 콜백 기반 프로그래밍 모델은 코드를 작성하고 디버깅하기가 어렵다
- API 게이트웨이의 요청 처리 로직의 성격에 따라 적절한 모델을 선택해야 함
  - I / O 집약적 로직(ex. 요청 라우팅)을 수행하는 API 게이트웨이는 논블로킹 I / O 를 사용하면 네트워크 접속 비용이 감소함
  - CPU 집약적 로직(ex. 복호화, 압축)을 수행하는 API 게이트웨이는 NIO 사용으로 인한 개선효과가 없음


### **리액티브 프로그래밍 추상체 이용**
- API 조합 처리 시 응답 시간을 줄이려면 가능한 한 동시에 서비스를 호출하는 동시성 코드를 작성해야 한다
- 동시성 코드를 비동기 콜백 방식으로 작성하면 콜백 지옥 callback hell 에 빠지기 쉽기 때문에 코드가 뒤얽혀 알아보기 힘들고 에러가 나기 쉽다
- API 조합 코드는 자바 8 CompletableFutures, 리액터 프로젝트 Mono, RxJava의 옵저버블 observable 같은 JVM 용 리액티브 추상체나 Node.js 의 프라미스 promise 를 활용하여 리액티브한 선언형 스타일로 작성해야 한다


### **부분 실패 처리**
- API 게이트웨이의 안정성을 보장하기 위해 부하 분산기 후면에 여러 게이트웨이 인스턴스를 두고 가동한다
- 실패한 요청, 지연 시간이 너무 긴 요청을 처리하기 위해 회로 차단기 패턴을 사용한다


### **선량한 시민 good citizen 되기**
- 선량한 시민 : 다른 사람에게 부정적인 영향을 끼치지 않고 자신이 맡은 바 임무를 충실히 수행하는 시민
- API 게이트웨이도 애플리케이션의 구성 요소 중 하나 이므로 다른 서비스에 사용되는 서비스 디스커버리 패턴, 관측성 패턴 등 아키텍처에 알맞게 선정된 패턴을 구현해야 한다 


* * *


## **API 게이트웨이 구현**


### **기성 off-the-shelf API 게이트웨이 제품 / 서비스 활용**
- 개발 공수는 거의 안들지만 유연성이 떨어지며, 대체로 API 조합을 지원하지 않는다
- AWS API 게이트웨이 
  - 하나 이상의 HTTP 메서드를 지원하는 REST 리소스 세트로 필요 시 템플릿 기반으로 요청 / 응답을 변환하도록 구성할 수 있고, 요청 인증 기능도 내장되어 있음
  - 대부분의 API 게이트웨이 요건을 충족하고 초기 구성만 하면 설치 / 운영을 신경 쓸 필요가 없다
  - API 조합을 지원하지 않고, JSON 위주의 HTTP(S), 서버 쪽 디스커버리 패턴만 지원된다
- AWS 애플리케이션 부하 분산기 ALB
  - HTTP, HTTPS, 웹 소켓, HTTP/2 용 부하 분산기로 AWS API 게이트웨이와 비슷한 기능을 제공
  - 기본적인 API 게이트웨이로서의 요건을 충족하고 직접 설치 / 운영할 필요가 없다
  - HTTP 메서드 기반의 라우팅, API 조합, 인증 로직은 없다
- 기타 API 게이트웨이
  - 콩 Kong : 엔진엑스 HTTP 서버를 기반으로 HTTP 메서드, 헤더, 경로를 이용하여 라우팅 규칙을 구성할 수 있고, 엣지 기능이 구현된 플러그인을 끼워넣을 수 있다
  - 트래픽 Traefik : Go 언어로 작성되어 HTTP 메서드, 헤더, 경로를 이용하여 라우팅 규칙을 구성할 수 있고, 서비스 레지스트리와 연계하는 기능을 제공한다
  - API 조합을 지원하지 않으며, 직접 설치, 구성, 운영해야 한다


### **API 게이트웨이 자체 개발**
- API 게이트웨이 프레임워크 또는 웹 프레임워크를 기반으로 직접 API 게이트웨이를 개발하므로 적잖은 개발 노력이 필요하다
- 코딩 복잡도를 최소화할 수 있는 라우팅 규칙 정의 매커니즘을 구현해야 하며, HTTP 헤더 처리 등 HTTP 프록시 로직을 정확히 구현해야 한다
- 넷플릭스 주울
  - 라우팅, 사용량 제한, 인증 같은 엣지 기능이 탑재된 프레임워크
  - HTTP 요청을 변환하는 필터 체인을 적절히 조합해서 요청을 처리하고, 백엔드 서비스를 호출 후 클라이언트에 반환하기 직전에 응답을 가공함
  - 스프링 클라우드 주울을 사용하면 구성보다 관습 convention over configuration 방식으로 손쉽게 개발 가능
  - 스프링 MVC 컨트롤러를 정의하면 API 조합 구현이 가능
  - 경로 기반의 라우팅만 지원하기 때문에 HTTP 메서드에 따라 다른 서비스로 라우팅하는 것이 불가능함
- 스프링 클라우드 게이트웨이
  - 스프링 5, 스프링 부트 2, 스프링 웹플럭스(리액터 프로젝트 기반의 리액티브 웹 프레임워크) 등의 프레임워크를 토대로 한 API 게이트웨이 프레임워크
  - 요청 라우팅, API 조합, 인증 등의 엣지 기능 처리를 지원
  - ApiGatewayMain 패키지, 하나 이상의 API 패키지, 프록시 패키지로 구성


### **그래프 기반 API**
- 스키마 주도 API 기술
  - 데이터를 효율적으로 가져오도록 설계된 그래프 기반의 스키마로 서버 API를 구성하는 API 프레임워크
  - 그래프 기반 스키마는 프로퍼티(필드) 및 다른 노드와 연관된 노드(타입)을 정의함
  - 클라이언트는 그래프 노드와 이들의 프로퍼티 / 관계 단위로 필요한 데이터를 지정해서 조회하기 때문에 원하는 데이터를 한 번에 가져올 수 있음
- 그래프 기반 API 기술의 장점
  - 클라이언트가 반환 데이터를 제어할 수 있기 때문에 다양한 클라이언트가 지원되는 유연한 단일 API를 개발할 수 있다
  - 서버 쪽 코드를 API 조합과 투사 projection 를 지원하도록 설계된 쿼리 실행 프레임워크로 작성하기 때문에 개발 수고를 덜 수 있다
- 넷플릭스 팔코
  - 서버 쪽 데이터를 가상 JSON 객체 그래프로 모델링하고 클라이언트는 이 JSON 객체의 프로퍼티를 팔코 서버에서 쿼리하여 데이터를 가져옴
  - 팔코 서버에서 객체 그래프의 프로퍼티는 백엔드 데이터 소스(ex. REST API를 가진 서비스)에 매핑됨
  - 서버는 백엔드 데이터 소스를 호출하여 프로퍼티를 setting / getting 하는 요청을 처리함
- GraphQL
  - 페이스북이 공개한 그래프 기반 API 기술로 서버 쪽 데이터를 필드와 다른 객체의 레퍼런스를 가진 객체 그래프로 모델링하고 객체 그래프는 백엔드 데이터 소스에 매핑됨
  - 클라이언트는 데이터를 조회하는 쿼리와 데이터를 생성 / 수정하는 변경을 실행할 수 있음
  - Node.js, 자바, 스칼라 등 다양한 언어로 작성된 클라이언트 / 서버에서 사용할 수 있음
  - GraphQL 스키마, 리졸버 함수, 프록시 클래스로 구성


**cf.Apollo GraphQL 기반 API 게이트웨이 구현 예**
- GraphQL 기반 API 게이트웨이 구성 요소
  - GraphQL 스키마 : 서버 쪽 데이터 모델 및 이 모델이 지원하는 쿼리를 정의
  - 리졸버 함수 : 스키마 엘리먼트를 다양한 백엔드 서비스에 매핑
  - 프록시 클래스 : 백엔드 서비스를 호출
  - 글루 코드 : GraphQL 서버와 Node.js 익스프레스 웹 프레임워크를 연계
- GraphQL 스키마 정의
  - 서버 쪽 데이터 모델과 작업(ex. 클라이언트가 수행 가능한 쿼리)의 구조를 정의한 타입들로 구성
  - 타입은 주로 객체형 타입과 이늄 enum 타입을 사용하며, 객체형 타입은 값을 반환하는 함수 개념인 필드를 가진다
  - 각각의 객체형 타입은 서버 쪽 데이터 모델의 엔터티와 대응된다
  - 관례상 Query라는 객체형 타입은 옵션 매개변수가 있는 네임드 쿼리와 반환형으로 정의된 필드로 클라이언트에서 실행 가능한 쿼리를 정의한다
- GraphQL 쿼리 실행
  - 클라이언트는 쿼리 문서가 담긴 요청을 서버에 전송하여 쿼리를 실행한다
  - 쿼리 문서는 쿼리명, 인수 값, 반환될 결과 객체 필드를 명시하며, 한번에 여러 필드를 조회하는 여러 쿼리를 실행하도록 작성될 수도 있다
  - 클라이언트는 쿼리 문서로 원하는 데이터를 정확히 특정할 수 있다
- 스키마와 데이터 연결
  - 스키마에 정의된 객체형 필드에 리졸버 함수를 붙여서 GraphQL 스키마와 데이터 소스를 연관 지을 수 있다
  - 아폴로 GraphQL 서버는 이중 중첩된 자바 스크립트 객체를 생성하여 최상위 프로퍼티는 각각 객체형과 대응시키고, 2차 프로퍼티는 각각 해당 필드의 리졸버 함수를 정의한다
  - 리졸버 함수는 객체, 쿼리 인수, 컨텍스트를 매개 변수로 받아서 단일 서비스를 호출하거나 API를 조합해서 여러 서비스의 데이터를 가져올 수 있다
  - GraphQL은 재귀 알고리즘을 이용해서 제일 먼저 Query 문서에 지정된 최상위 쿼리의 리졸버 함수를 실행하고, 쿼리가 반환한 객체마다 Query 문서에 지정된 필드를 하나씩 순회하며 필드에 달려있는 리졸버를 호출한다
- 배칭 / 캐싱
  - 쿼리 실행 시 엄청나게 많은 리졸버를 실행하게 될 가능성이 있기 때문에 성능 최적화를 위해서 서버 쪽에서 배칭 / 캐싱을 조합하여 사용한다
  - 배칭 : 서비스를 N번 호출할 것을 N개 객체를 일괄 조회하는 호출 한 번으로 전환하는 기술
  - 캐싱 : 불필요한 중복 호출을 방지하기 위해 동일한 객체를 가져왔던 이전 결과를 재사용하는 기술
  - 데이터로더 DataLoader 모듈 : Node.js 기반의 GraphQL 서버에서 단일 이벤트 루프 실행 중 발생한 로드를 취합해서 배치 로딩 함수를 호출하고 호출을 캐시함
- 익스프레스 연계
  - 클라이언트가 아폴로 GraphQL 서버를 호출하기 위해 아폴로 GraphQL 서버와 Node.js 익스프레스 웹 프레임워크를 연계
  - graphqlExpress 함수 : 실행 가능한 스키마에 대해 GraphQL 쿼리를 실행하는 익스프레스 요청 핸들러를 생성하는 함수
  - 익스프레스 웹 프레임워크는 GraphQL 서버 호출을 GraphQL 요청 핸들러로 라우팅한다
- GraphQL 클라이언트 작성
  - GraphQL 서버는 HTTP 기반의 API를 제공하므로 일반적인 HTTP 클라이언트로도 접근 가능하지만 GraphQL 클라이언트를 사용하면 클라이언트 쪽 캐싱 등의 기능도 사용 가능함
  - GraphQL 클라이언트는 클라이언트가 원하는 데이터를 조회하는 다양한 쿼리 메서드를 정의할 수 있음