---
layout: default
title: Data Query
parent: Micro Service Architecture Pattern
nav_order: 6
---

# Data Query
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **API 조합 패턴**

### **API 조합 패턴 개요**
- 서비스 클라이언트가 API를 통해 데이터를 가진 여러 서비스를 직접 호출하여 그 결과를 조합하는 패턴으로 API 조합기와 둘 이상의 프로바이더 서비스로 구성됨
- API 조합기 : 프로바이더 provider 서비스를 쿼리하여 데이터를 조회하는 클라이언트 또는 API 게이트웨이
- 프로바이더 서비스 : 최종 결과로 반환할 데이터의 일부를 갖고 있는 서비스로 애그리거트 하나에 해당하는 응답을 반환하는 API 를 제공함
- 대부분의 경우 API 조합 패턴으로 쿼리 작업 구현이 가능함


### **API 조합 설계 이슈**
- API 조합기 역할의 컴포넌트 선정
  - 서비스 클라이언트 : 웹 애플리케이션 처럼 방화벽 내에 있는 클라이언트는 효율적으로 데이터를 조회할 수 있지만, 클라이언트가 방화벽 외부에 있고 네트워크가 느리면 실용적이지 않음
  - API 게이트웨이 : 쿼리 작업이 애플리케이션의 외부 API 중 하나라면 외부 API가 구현된 API 게이트웨이에 API 조합 로직을 구현하면 방화벽 외부 클라이언트가 API 호출 한 번으로 데이터를 조회할 수 있어 효율적임
  - 스탠드얼론 서비스로 구현 : 내부적으로 여러 서비스가 사용하는 쿼리 작업이거나 취합 로직이 너무 복잡해서 API 게이트웨이의 일부로 만들기에 곤란한 경우 API 조합기를 스탠드얼론 서비스로 구현
- 지연 시간 최소화를 위한 효율적 취합 로직 작성
  -  가능한 한 API 조합기가 프로바이더 서비스를 병렬 호출해야 효율적이지만 경우에 따라 순차 호출해야만 하는 경우도 있음
  - 순차 / 병렬 서비스 호출이 뒤섞인 실행 로직은 복잡할 수 있으므로 관리가 용이하고 성능 / 확장성이 우수한 CompletableFuture, RxJava의 옵저버블, 또는 이와 동등한 추상체에 기반한 리액티브 설계 기법을 사용해야 함


### **API 조합 패턴의 장단점**
- 쉽고 단순하게 쿼리 작업을 구현할 수 있다
- 여러 서비스를 호출하고 여러 DB를 쿼리하므로 오버헤드가 증가한다 
- 하나의 쿼리 작업에 적어도 세 서비스가 반드시 개입되는 구조라서 가용성이 저하될 우려가 있다
  - 프로바이더 서비스가 불능일 경우 API 조합기가 이전에 캐시한 데이터를 반환
  - 일시 불능 상태인 서비스의 데이터를 제외한 미완성된 데이터를 반환
- 한 트랜잭션으로 수행되지 않아서 일관되지 않은 데이터가 반환될 수 있다


* * *


## **CQRS 패턴**


### **CQRS 의 필요성**
- 필터 조건이 포함된 다중 서비스 쿼리의 경우 모든 서비스가 필터 / 정렬 용도의 속성을 보관하지 않을 수 있어 값비싸고 비효율적인 인-메모리 조인을 해야 한다
  - API 조합기로 필터 속성이 포함되지 않은 모든 데이터를 인-메모리 조인하는 경우 데이터 크기가 커져서 효율이 떨어지는 문제가 있다
  - API 조합기로 필터 속성이 포함된 데이터를 먼저 조회하고 해당 데이터에 대한 다른 서비스 데이터를 요청하는 경우 다른 서비스가 대량 조회 API 를 제공하지 않으면 과도한 네트워크 트래픽이 유발된다
  - 다중 서비스 쿼리 작업을 API 조합기에 구현하는 것은 RDBMS 쿼리 실행 엔진에 탑재된 기능을 애플리케이션으로 옮기는 비효율적인 작업이다
- 서비스 DB 또는 데이터 모델이 효율적인 쿼리를 지원하지 않을 수 있다
  - 예를 들어 지리 공간을 검색하는(위치를 기준으로 찾는) 쿼리를 수행하는 경우 지리 공간 데이터형, 인덱스, 쿼리 기능이 내장된 DB(MongoDB, Postgres, MySQL의 지리 공간 확장팩 등)를 사용하면 쉽게 구현할 수 있지만 그렇지 않은 경우 구현하기가 까다롭다
  - 테이블을 일종의 지리 공간 인덱스로 사용하는 지리 공간 인덱싱 라이브러리를 사용하거나(DynamoDB 등), 데이터의 레플리카를 지리 공간 검색을 지원하는 DB에 저장하고 최종 일관된 eventually consistent 상태를 유지해야 한다
- 데이터를 가진 서비스에 쿼리를 구현하는 것이 부적절한 경우 관심사를 분리할 필요가 있다
  - 데이터를 소유한 서비스와 데이터를 필요로 하는 서비스가 다른 경우 단순히 데이터 소유권에 따라 쿼리를 구현한 경우 관심사가 분리되지 않는 문제가 있다
  - 해당 쿼리 작업이 데이터를 소유한 서비스의 주된 관심사가 아니라면 쿼리 작업을 유지 보수하는 것이 어렵기 때문에 데이터를 필요로 하는 서비스가 쿼리를 구현하고 데이터를 소유한 서비스는 데이터만 제공하는 구조가 낫다


### **CQRS 개요**
- CQRS 커맨드 쿼리 책임 분리 
  - 여러 서비스에 있는 데이터를 가져오는 쿼리는 해당 서비스의 데이터를 이벤트를 이용하여 복제한 읽기 전용 뷰를 사용하는 패턴
  - 엔터프라이즈 애플리케이션에서 레코드 관리는 RDBMS 의 트랜잭션 기능을 활용하고, 텍스트 검색 쿼리는 쿼리 능력이 탁월한 일래스틱서치나 솔라 등의 텍스트 검색 DB를 이용하는 아키텍처를 일반화한 것
  - CQRS는 텍스트 검색 엔진 뿐만 아니라 훨씬 다양한 종류의 DB를 활용할 수 있고, 이벤트 구독을 통해서 거의 실시간으로 동기화된다
- 관심사의 분리 / 구분
  - 생성 / 수정 / 삭제 CUD 기능을 주로 담당하는 데이터 모델 및 커맨드 모듈과 조회 R 기능을 담당하는 데이터 모델 및 쿼리 모듈로 영속적 데이터 모델과 모듈을 나누어 구현
  - 비CQRS 서비스는 하나의 영속적 데이터 모델이 커맨드와 쿼리를 모두 지원하며, 일반적인 CRUD 작업은 도메인 모델로 구현하고 그 중 성능이 중요한 쿼리 작업은 직접 DB에 접속하여 처리하기도 한다
  - CQRS 서비스에서 커맨드 도메인 모델은 CUD 작업과 단순한 조회 작업을 처리하고 자체 DB에 매핑되며, 데이터가 바뀔 때마다 도메인 이벤트를 발행한다
  - 별도로 나뉘어진 쿼리 모델은 다소 복잡한 쿼리를 처리하는 다양한 종류의 DB를 가질 수 있고, 커맨드 모델의 도메인 이벤트를 구독하고 DB(들)를 업데이트하는 이벤트 핸들러를 가진다
- 쿼리 전용 서비스
  - 커맨드 작업이 전혀 없는 오직 쿼리 작업만으로 구성된 API와 하나 이상의 다른 서비스가 발행한 이벤트를 구독하여 항상 최신 상태로 유지되는 DB를 쿼리하는 로직이 구현된 서비스
  - 여러 서비스가 발행한 이벤트를 구독해서 구축된 뷰를 구현하기 좋은 방법으로 특정 서비스에 종속되지 않기 때문에 스탠드얼론 서비스로 구현
  - 한 서비스가 가진 데이터를 복제한 뷰를 구현하는 수단으로도 유용하게 사용 가능


### **CQRS 장점**
- 여러 서비스의 데이터를 조회하는 쿼리를 효율적으로 구현할 수 있다
- 각 쿼리가 효율적으로 구현된 특화된 DB를 사용할 수 있어 다양한 쿼리를 효율적으로 구현할 수 있다
- 이벤트 소싱 애플리케이션에서 애그리거트 뷰를 CQRS 패턴으로 정의하면 기본키 쿼리만 지원하는 이벤트 저장소의 한계를 극복하여 애그리거트를 쿼리할 수 있게 해준다 
- 커맨드 쪽, 쿼리 쪽에 각각 알맞은 코드 모듈과 DB 스키마를 별도로 정의하여 관심사가 분리되고 관리하기 간편해지고, 쿼리를 구현한 서비스와 데이터를 소유한 서비스를 달리할 수 있게 된다


### **CQRS 단점**
- 아키텍처가 복잡해지고 별도의 데이터 저장소를 관리해야 하는 운영 복잡도가 가중된다
- 커맨드 / 쿼리 뷰 사이의 복제 시차 replication lag를 처리해야 한다
  - 커맨드 / 쿼리 API 가 클라이언트에 버전 정보를 전달해서 클라이언트가 최신 데이터를 받을 때까지 쿼리 쪽 뷰를 계속 폴링하게 한다
  - 네이티브 모바일 앱이나 단일 페이지 애플리케이션 SPA 은 쿼리를 하지 않고 커맨드가 성공하면 커맨드가 반환한 데이터로 자신의 로컬 모델을 업데이트한다
- 가능한 한 API 조합 패턴을 사용하고 꼭 필요한 경우에만 CQRS 를 사용하는 것이 좋다


* * *


## **CQRS 뷰 설계**


### **CQRS 뷰 모듈**
- 뷰 DB : 뷰 모듈의 쿼리 작업을 효율적으로 구현할 수 있게 설계
- 데이터 접근 모듈 : DB 를 조회 / 수정
- 이벤트 핸들러 : 하나 이상의 서비스가 발행한 이벤트를 구독해서 DB를 업데이트
- 쿼리 API 모듈 : 하나 이상의 쿼리 작업으로 구성되어 데이터를 조회


### **뷰 DB 선택**
- NoSQL DB는 트랜잭션 기능이 제한적이고 범용적인 쿼리 능력이 없지만 데이터 모델이 유연하고, 성능 및 확장성이 우수한 반면 SQL DB는 개발자에 익숙하고 특수한 비관계형 기능(지리 공간 검색 등)을 추가할 수 있으며 리포팅 엔진을 지원하는 장점이 있다 
- CQRS 뷰는 단순 트랜잭션만 사용하고 고정된 쿼리만 실행하므로 NoSQL DB의 제약 사항에 영향을 받지 않아 NoSQL DB와 잘 맞는 편이다
- 쿼리 작업의 특성에 맞게 SQL 또는 NoSQL DB를 사용한다
  - JSON 객체를 PK로 검색 : 문서형 스토어(MongoDB, DynamoDB 등), 키-값 스토어(Redis) 사용
  - 쿼리 기반의 JSON 객체 검색 : 문서형 스토어
  - 텍스트 쿼리 : 텍스트 검색 엔진(일래스틱서치 등)
  - 그래프 쿼리 : 그래프 DB(Neo4j)
  - 전통적인 SQL 리포팅 / BI : 관계형 DB
- 이벤트 핸들러가 실행할 업데이트 작업 역시 효율적으로 구현되어야 한다
  - 이벤트 핸들러는 대개 레코드를 기본키로 찾아 수정 / 삭제하지만 외래키를 이용하여 수정 / 삭제해야 하는 경우도 있다
  - 기본키 기반 수정 / 삭제만 지원하는 DB(DynamoDB 등)는 보조 인덱스 등으로 외래키와 기본키를 매핑한 데이터를 DB에 갖고 있어야 외래키로 업데이트가 가능하다


### **데이터 접근 모듈 설계**
- 데이터 접근 객체 DAO 및 헬퍼 클래스로 구성
- DAO : 이벤트 핸들러가 호출한 업데이트 작업과 쿼리 API 모듈이 호출한 쿼리 작업을 실질적으로 수행하고, 자료형과 DB API 간 매핑 및 동시 업데이트 처리, 업데이트 멱등성 보장 등의 작업을 처리함
- 동시 업데이트 처리 
  - 뷰가 여러 종류의 애그리거트가 발행한 이벤트를 구독할 경우 여러 이벤트 핸들러가 동일한 레코드에 업데이트할 수 있다
  - DAO는 낙관적 잠금이나 비관적 잠금을 적용해 동시 업데이트로 서로의 데이터를 덮어 쓰지 않도록 작성되어야 한다
  - DAO는 DB 레코드를 먼저 읽지 않고 업데이트하는 방식으로 동시 업데이트를 처리할 수도 있다 
- 업데이트 멱등성 보장
  - 이벤트 핸들러는 같은 이벤트를 한 번 이상 넘겨받고 호출될 수 있으므로 이벤트 ID를 기록하고 데이터 저장소를 원자적으로 업데이트하여 중복 이벤트를 솎아 내야 한다
  - SQL DB를 사용하면 처리된 이벤트를 뷰 업데이트 트랜잭션의 일부로 PROCESSED_EVENTS 테이블에 삽입하고, NoSQL DB를 사용하면 업데이트하는 데이터 저장소 레코드에 이벤트를 저장한다
  - 레코드에 이벤트를 저장하는 경우 레코드가 단일 애그리거트 인스턴스에 해당된다면 각 레코드에 max(eventId)를 저장하고, 레코드가 여러 애그리거트의 이벤트가 조합된 결과면 애그리거트 타입, 애그리거트 ID에 대한 max(eventId) 맵을 저장해야 한다
  - 이벤트 ID 를 이용하면 커맨드 작업에 의해 발행된 이벤트 ID가 아직 뷰에 적용되지 않았을 경우 에러를 반환하는 방식으로 데이터의 비일관성을 감지하도록 만들 수 있다(복제 시차 처리)


### **뷰 추가 및 변경**
- CQRS 뷰는 새로운 쿼리를 지원하기 위해 새로운 뷰가 추가되거나, 스키마가 변경되어서 뷰를 재생성해야 하는 경우가 발생할 수 있다
- 단순히 이벤트 핸들러만 추가 / 변경하는 것으로 뷰가 새롭게 생성되거나 재생성되지 않을 수 있다
- 아카이빙된 이벤트 이용
  - RabbitMQ 같은 메시지 브로커는 컨슈머가 메시지를 처리한 직후 메시지를 삭제 하며, 아파치 카프카 같은 브로커 역시 설정된 시간 동안만 메시지를 보관하므로 뷰를 구축하는 데 필요한 이벤트가 메시지 브로커에 없을 수 있다
  - 빅데이터 기술을 응용하여 아카이빙된 오래된 이벤트도 가져와야 한다
- 단계적 구축
  - 전체 이벤트를 처리하는 시간 / 리소스가 점점 증가하므로 뷰 추가 및 재생성은 점점 느려지고 비용이 많이 들게 된다
  - 2단계 증분 알고리즘 two-step incremental algorithm을 적용하여 주기적으로 각 애그리거트 인스턴스의 스냅샷을 이전 스냅샷과 그 이후 이벤트로 생성하고, 최종 스냅샷과 그 이후 이벤트를 이용하여 뷰를 생성한다 


* * *


## **CQRS 뷰 구현**


### **이벤트 핸들러**
- 이벤트로부터 전달받은 인수를 DAO 메서드에 넘겨 호출함
- 이벤트와 이벤트에 관한 메타데이터가 담겨 있는 하나의 DomainEventEnvelope 형 매개변수를 받음
- makeSourceEvent 메서드 : 이벤트를 발생시킨 애그리거트 타입과 ID, 이벤트 ID가 포함된 SourceEvent를 생성


### **DB 데이터 모델링 및 쿼리 설계**
- 테이블 설계 
  - 기본키 정의 및 클래스의 필드와 아이템의 속성(DynamoDB의 경우) 매핑
- 쿼리 전용 인덱스 정의 
  - 쿼리 작업을 효율적으로 수행하도록 추가적인 인덱스 정의
  - DynamoDB의 경우 정렬된 검색 결과를 쿼리하려면 테이블이 파티션 키 partition key 와 정렬 키 sort key 가 조합된 기본키를 갖고 있어야 한다
  - 파티션 키와 정렬 키의 조합이 유일한 데이터를 가리키지 않는 경우 테이블의 기본키로 적합하지 않으므로 파티션 키와 정렬 키의 조합을 비 유일 non-unique 키로 가지는 보조인덱스 secondary index 를 사용한다
  - 보조 인덱스는 RDBMS 인덱스처럼 테이블이 업데이트될 때 자동 업데이트 되지만, 비식별 non-key 속성을 가질 수 있어 성능이 향상되며 필터 용도로도 사용 가능하다
  - 파티션 키 : DynamoDB를 Z축 확장할 때 아이템의 저장소 파티션을 선택하는 키
  - 비식별 속성 : 애플리케이션이 테이블에서 가져올 필요 없이 쿼리로 반환할 수 있는 값 
- 쿼리 구현
  - 정렬 키에 검색 기준 search criteria 이 있는 경우 정렬키에 범위 제약을 걸 수 있는 조건 표현식으로 구현할 수 있음
  - 비식별 속성에 해당되는 검색 기준은 Boolean 표현식인 필터 표현식 filter expression 을 이용하여 구현 가능함
  - 키워드 검색은 키워드 필터 기준 항목을 토큰화 tokenizing 한 후 키워드들을 keywords 라는 세트 값 속성에 저장하는 방식으로 검색함
- 쿼리 결과 페이지네이션
  - DynamoDB는 위치 기반의 페이지네이션은 지원하지 않음
  - 반환할 아이템의 최대 개수를 pageSize 매개변수로 지정
  - 이보다 많은 아이템이 검색되면 쿼리 결과에 LastEvaluatedKey 라는 NOT NULL 속성이 포함됨
  - 다음 페이지를 조회할 때 exclusiveStartKey 매개변수를 LastEvaluatedKey로 세팅하여 호출
  - 위치 position 기반 페이지네이션 : 페이지 번호 page 와 조회 건수 size 를 매개변수로 전달하는 방식 
- 업데이트
  - PutItem() : DynamoDB에서 기본키로 찾은 아이템을 생성 또는 대체하는 작업으로 동일한 아이템을 동시 업데이트할 경우 정확히 처리된다는 보장이 없음
  - UpdateItem() : DynamoDB에서 개별 아이템 속성을 업데이트하고, 필요 시 아이템을 생성하는 작업으로 상이한 이벤트 핸들러가 상이한 아이템 속성을 업데이트할 경우 사용하며, 아이템을 테이블에서 미리 가져올 필요가 없기 때문에 효율적임 
- 중복 이벤트 감지
  - 이벤트 핸들러가 멱등해도 중복 이벤트를 접수한 이벤트 핸들러가 아이템 속성을 과거 값으로 세팅할 가능성은 항상 있기 때문에 간혹 아이템이 일시적으로 최신 상태가 아닐 수 있다
  - UpdateItem() 작업의 조건부 업데이트 conditional update 메커니즘을 활용하면 중복 이벤트가 아닐 때에만 아이템을 업데이트 할 수 있다
  - 조건부 표현식으로 이벤트ID 속성이 존재하지 않거나, 이벤트ID가 가장 마지막에 처리된 이벤트 ID보다 클 경우에만 업데이트를 허용한다


### **DAO 클래스**
- 테이블의 아이템을 읽고 쓰는 메서드가 구현된 클래스로 업데이트 메서드는 이벤트 핸들러가, 쿼리 메서드는 쿼리 API 모듈이 각각 호출함
- add*() 메서드 
  - item, sourceEvent 두 매개변수를 받아 테이블에 Item을 추가하는 메서드
  - sourceEvent 에는 이벤트를 발생시킨 애그리거트의 aggregateType, aggregateId, eventId가 있고 조건부 업데이트를 구현하는 용도로 쓰인다
- update*() 메서드
  - itemId, sourceEvent 두 매개변수를 받아 Item 상태를 변경하는 메서드
- idempotentUpdate() 메서드 
  - 중복 업데이트를 방지하는 조건부 표현식을 추가한 후 업데이트를 수행하는 헬퍼 메서드
  - SourceEvent.addDuplicateDetection() 을 호출해 조건부 표현식을 추가하고, 중복 이벤트일 경우 ConditionalCheckFailedException 예외를 붙잡아 아무 일도 하지 않는다
- find*() 메서드
  - 보조 인덱스를 이용하여 테이블을 쿼리하여 아이템을 조회하는 메서드
  - getLastEvaluatedKey() 가 반환한 값을 JSON 토큰으로 직렬화하는 식으로 페이지네이션을 구현
  - 클라이언트가 시작 토큰을 지정한 경우 토큰을 직렬화하고 withExclusiveStartKey()로 시작키를 세팅함 
