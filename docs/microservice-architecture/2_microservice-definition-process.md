---
layout: default
title: Micro Service Architecture Definition Process
parent: Micro Service Architecture Pattern
nav_order: 2
---

# Micro Service Architecture Definition Process
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **시스템 작업 식별**


### **고수준 도메인 모델 생성**
- 시스템 작업의 동작을 기술하는 데 필요한 vocabulary를 정의하는 핵심 클래스로 구성된 고수준의 도메인 모델을 생성
- 사용자 스토리와 사용자 시나리오 등의 애플리케이션 요건에 포함된 명사를 분석하고 도메인 전문가와 상담하여 클래스 다이어그램을 생성


### **시스템 작업을 도메인 모델로 정의**
- 애플리케이션이 어떤 요청을 처리할 지 시스템 작업 식별 후 그 동작을 도메인 모델 관점에서 기술
- 시스템 작업은 크게 커맨드 command (데이터 생성, 수정, 삭제 CUD)와 쿼리 query (데이터 읽기 R)로 나뉨
- 시스템 커맨드는 사용자 스토리 / 시나리오 의 동사에서 도출하며 매개변수, 반환값, 선행 조건 precondition 과 후행 조건 postcondition 을 포함하는 동작 방식의 명세를 도메인 모델 클래스로 정의
- 선행 조건은 사용자 시나리오의 전제 given를, 후행 조건은 사용자 시나리오의 결과 then를 나타내고, 시스템 작업은 선행 조건을 확인한 후, 후행 조건을 만족시키는 액션을 수행함
- 시스템 쿼리는 시스템이 사용자가 의사 결정을 하는데 필요한 정보를 제공함


* * *


## **서비스 식별**


### **비즈니스 능력별 분해 패턴**
- 비즈니스 능력 : 비즈니스가 가치를 생산하기 위해 하는 일
- 비즈니스를 처리하는 방법은 변하지만 비즈니스 능력은 크게 달라지지 않으므로 비즈니스 능력에 따라 서비스를 구성하면 비교적 안정적인 아키텍처를 구축할 수 있다
- 비즈니스 능력은 조직의 목표, 구조, 비즈니스 프로세스를 분석하여 식별하며, 특정 비즈니스 객체를 중심으로 여러 개의 하위 능력으로 분해 가능하다
- 비즈니스 능력 또는 연관된 능력 그룹에 따라 서비스를 매핑하여 서비스를 정의한다


### **하위 도메인별 분해 패턴**
- 도메인 주도 설계 Domain Driven Design : 객체 지향 도메인 모델 중심의 복잡한 소프트웨어 애플리케이션을 구축하는 방법 [참고. Domain Driven Design 이란 무엇인가?](https://frontalnh.github.io/2018/05/17/z_domain-driven-design/)
- DDD는 도메인을 구성하는 각 하위 도메인 sub-domain 마다 범위가 분명한 bounded context 도메인 모델을 따로 정의함
- 하위 도메인은 비즈니스 능력과 같은 방법으로 식별하므로 비즈니스 능력과 유사한 하위 도메인이 도출됨
- 경계 컨텍스트 bounded context 는 도메인 모델의 범위로 도메인 모델을 구현한 코드 아티팩트를 포함하며, 각 서비스가 경계 컨텍스트가 된다 
- 하위 도메인에 따라 서비스를 매핑하여 서비스를 정의한다


### **서비스 분해 지침**
- 단일 책임 원칙 SRP, Single Responsibility Principle : 클래스는 오직 하나의 변경 사유를 가져야 한다.
- 단일 책임 원칙은 클래스가 변경될 잠재적 사유인 클래스가 맡은 책임이 하나인 클래스를 정의해야 한다는 의미
- 공동 폐쇄 원칙 CCP, Common Closure Principle : 패키지의 클래스들은 동일한 유형의 변경에 대해 닫혀 있어야 한다. 패키지에 영향을 주는 변경은 그 패키지에 속한 모든 클래스에 영향을 끼친다.
- 공동 폐쇄 원칙은 동일한 사유로 변경되는 클래스는 동일한 패키지에 있어야 한다는 의미


### **서비스 분해의 장애요소**
- 네트워크 지연 : 배치 API를 구현하거나 IPC를 메서드나 함수 호출로 대체
- 동기 IPC 로 인한 가용성 저하 : 비동기 메시징으로 강한 결합도를 제거
- 여러 서비스에 걸친 데이터 일관성 유지 : 메시징을 이용한 로컬 트랜잭션 사가를 사용해 최종 일관성 eventual consistency 을 보장
- 일관된 데이터 뷰 확보 : 전역 범위에서 일관된 데이터 뷰 확보 필요
- 만능 클래스 : DDD를 적용하여 애플리케이션 곳곳에서 사용되는 만능 클래스를 개별 하위 도메인으로 분리


* * *


## **서비스 API(작업과 이벤트) 정의**


### **시스템 작업을 서비스로 배정**
- 요청의 진입점에 해당하는 서비스를 결정
- 작업이 제공하는 정보가 필요한 서비스에 작업을 배정
- 작업을 처리하는 데 필요한 정보를 갖고 있는 서비스에 작업을 배정


### **서비스 간 협동 지원에 필요한 API 확정**
- 여러 서비스에 걸쳐있는 작업의 경우 호출이 필요한 서비스와 API를 결정
- API 구현 시 사용할 IPC 에 따라 타 서비스 호출 전용으로 만들어진 작업 이나 이벤트 발행을 결정
- 프로세스 간 통신 IPC 관련 내용 참고 [프로세스 간 통신]({{ site.baseurl }}{% link docs/microservice-architecture/3_1_inter-process.md %}) 
