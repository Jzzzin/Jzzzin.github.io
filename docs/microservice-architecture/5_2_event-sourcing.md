---
layout: default
title: Event Sourcing 
parent: Business Logic
grand_parent: Micro Service Architecture Pattern
nav_order: 2
---

# Event Sourcing
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **이벤트 소싱 패턴**


### **기존 영속화의 문제점**
- 기존 영속화 방식 
  - 클래스 - DB 테이블, 클래스 필드 - 테이블 컬럼, 클래스 인스턴스 - 테이블 로우 에 매핑하는 방식
  - JPA 같은 ORM 프레임워크나 MyBATIS 등의 저수준 프레임워크를 사용
- 객체-관계 임피던스 부정합 object-relational impedance mismatch 
  - 테이블 형태의 관계형 스키마와 관계가 복잡한 리치 도메인 모델 rich domain model 의 구조는 근본적인 개념부터 다르기 때문에 객체-관계 매핑은 부조화를 일으킬 수 밖에 없다
  - 리치 도메인 모델 : 도메인과 관련된 비즈니스 로직을 직접 도메인 객체에 넣은 도메인 모델 cf. 아네믹 데이터 모델 anemic data model : 데이터 값을 저장하는 VO 역할 정도로만 도메인 객체를 활용
- 애그리거트 이력이 없음 : 기존 영속화 매커니즘은 애그리거트의 현재 상태만 저장하므로 애그리거트 이력을 관리하려면 별도의 코드 구현이 필요하다
- 감사로깅을 구현하기 힘들고 오류가 자주 발생한다 : 감사 로깅 코드 및 비즈니스 로직이 계속 분화하기 때문에 버그가 날 가능성이 높다
- 이벤트 발행 로직이 비즈니스 로직에 추가된다 : 도메인 이벤트 발행을 지원하지 않기 때문에 이벤트 생성 로직을 추가해야 하는데 비즈니스 로직과 동기화되지 않을 위험이 있다


### **이벤트 소싱 개요**
- 애그리거트의 상태 변화를 나타내는 일련의 도메인 이벤트로 애그리거트를 저장하는 방식
- 애플리케이션은 애그리거트의 이벤트를 로드하고, 기본 생성자를 호출하여 애그리거트 인스턴스를 생성한 후 이벤트를 하나씩 순회하며 apply()를 호출해 이벤트의 현재 상태를 재연 replay 함 
  - 폴드 fold / 리듀스 reduce 작업 : 함수형 프로그래밍에서 연산 operation 과 누산기 accumulator로 컬렉션에 있는 값들을 처리하여 더 작은 컬렉션이나 단일 값을 생성하는 작업
- 모든 애그리거트의 상태 변화를 도메인 이벤트로 나타내며, 애그리거트는 상태가 바뀔 때마다 반드시 이벤트를 발생시킴
- 이벤트는 애그리거트가 상태 전이를 하기 위해 필요한 모든 데이터를 갖고 있어야 함
- 애그리거트를 업데이트하는 커맨드 메서드는 둘 이상의 메서드로 리팩터링됨
  - 요청을 나타낸 커맨드 객체를 매개변수로 받아 애그리거트의 상태 변경을 나타낸 이벤트 목록을 반환하는 메서드
  - 정해진 이벤트 타입을 매개변수로 받아 애그리거트를 업데이트하는 메서드


### **이벤트 발행**
- 트랜잭셔널 메시징 패턴을 사용하여 이벤트를 발행할 수 있지만, 이벤트를 OUTBOX 테이블에 잠깐 저장했다 지우는 것이 아니라 EVENTS 테이블에 영구히 저장하는 차이점이 있다
- 폴링
  - 이벤트 발생기는 EVENTS 테이블을 계속 폴링하면서 메시지 브로커에 발행
  - EVENTS 테이블에 이벤트 발행 여부를 추적할 수 있는 컬럼을 추가하여 모든 이벤트가 발행되도록 함
- 트랜잭션 로그 테일링 
  - 트랜잭션 로그를 테일링하여 EVENTS 테이블에 삽입된 이벤트를 읽어 메시지 브로커에 발행


### **스냅샷 사용**
- 수명이 긴 애그리거트는 이벤트 수가 많아서 일일이 로드 / 폴드 하기가 쉽지 않다
- 주기적으로 애그리거트 상태의 스냅샷을 저장하여 가장 최근에 뜬 스냅샷과 그 이후 발생한 이벤트만 가져오는 식으로 애그리거트 상태를 복원하면 성능이 개선된다
- 스냅샷을 사용할 경우 애그리거트 인스턴스는 기본 생성자가 아닌 스냅샷을 이용하여 재생성한다
- 복잡한 애그리거트는 메멘토 패턴으로 스냅샷을 뜰 수 있고, 단순하고 직렬화하기 쉬운 구조의 애그리거트는 JSON 직렬화 형태로 스냅샷을 뜰 수 있다


### **중복 메시지 처리**
- 메시지 브로커가 동일한 메시지를 여러 번 전송할 가능성이 있으므로 메시지 컨슈머는 중복 메시지를 솎아 낼 수 있도록 멱등하게 개발해야 한다 
- RDBMS 이벤트 저장소 사용 시
  -  비즈니스 로직이 애그리거트를 생성/수정하는 로컬 ACID 트랜잭션의 일부로 처리한 메시지 ID를 PROCESSED_MESSAGE 테이블에, 이벤트는 EVENTS 테이블에 삽입한다
- NoSQL 이벤트 저장소 사용 시 
  - 트랜잭션 모델이 제한적이므로 메시지 컨슈머가 처리한 메시지 ID를 애그리거트의 이벤트에 저장한다
  - 메시지 처리 결과 애그리거트가 이벤트를 발생시키지 않을 경우, 오직 메시지 ID를 기록할 목적으로 가짜 이벤트 pseudo event 를 저장한다
  - 가짜 이벤트는 이벤트 컨슈머가 무시해야 한다


### **도메인 이벤트 변경**
- 이벤트 구조는 시간의 흐름에 따라 달라지기 때문에 애플리케이션은 여러 버전의 이벤트를 처리해야 한다
- 이벤트 소싱에 기반한 애플리케이션의 스키마는 하나 이상의 애그리거트와 각 애그리거트가 발생시키는 이벤트로 구성되며 서비스 도메인 모델이 발전하면서 다양하게 변경된다
- 하위 호환성이 보장되는 스키마의 변경은 이벤트 컨슈머가 영향을 받지 않는다
- 하위 호환성이 보장되지 않는 변경은 이벤트 소싱 프레임워크의 업캐스터 upcaster 라는 컴포넌트가 이벤트를 로드할 때 구 버전의 이벤트를 신 버전으로 업데이트 하는 방식으로 처리한다


### **이벤트 소싱의 장점**
- 도메인 이벤트를 확실하게 발행하고 정확한 감사 로그를 제공하여 애플리케이션 통합 / 분석 / 모니터링 등의 용도로 활용할 수 있다
- 애그리거트마다 전체 이력이 그대로 보존되고, 애그리거트의 과거 상태를 쉽게 조회할 수 있다
- 애그리거트와 애그리거트를 직렬화한 표현형 사이를 간접화 할 수 있어 O / R 임피던스 불일치 문제를 거의 방지한다
- 애플리케이션 가동 중 발생한 모든 일을 기록하여 새로운 기능이 구현되기 이전에 해당 기능을 적용받는 사용자도 지원할 수 있다


### **이벤트 소싱의 단점**
- 새로운 프로그래밍 모델을 배우는 데 시간이 걸리고 비즈니스 로직을 다시 작성해야 한다
- 메시징 기반 애플리케이션은 복잡하다 - 이벤트 소싱 프레임워크를 사용하면 좀 간편해짐
- 이벤트를 발전시키기 어렵다 - 이벤트를 이벤트 저장소에서 가져올 때 최신 버전으로 업그레이드해야 함
- 데이터를 삭제하기 어렵다
  - 데이터가 의도적으로 영구 저장되므로 애그리거트는 소프트 삭제 soft delete (삭제 플래그를 세팅하여 애그리거트가 삭제 이벤트를 발생시키는 방식) 를 사용한다
  - 개인의 삭제 권리를 부여한 유럽 연합 일반 정보 보호 규정 GDPR 을 준수할 경우 사용자의 개인 정보를 망각하는 기능을 갖추어야 하므로 문제가 생길 수 있다
  - 암호화 encryption : 사용자마다 암호 키를 발급해서 별도의 DB 테이블에 저장하고, 애플리케이션은 사용자 개인 정보가 포함된 이벤트를 이벤트 저장소에 저장하기 전에 무조건 이 키로 암호화하면 사용자가 삭제를 요청했을 때 DB 테이블에 있는 암호화 키 레코드만 삭제하면 된다
  - 가명화 pseudonymization : 이메일 주소 같은 사용자 개인 정보를 애그리거트 ID로 쓸 경우 이메일 주소를 UUID 토큰으로 바꾸어 애그리거트 ID처럼 사용한다. UUID 토큰과 이메일 주소 간 연관 관계는 DB 테이블에 저장하고 개인 정보 삭제 요청 시 해당 테이블에서 해당 레코드만 삭제하면 된다. 
- 이벤트 저장소를 쿼리하기 어렵다 - NoSQL 이벤트 저장소의 경우 기본키 검색만 지원하므로 CQRS 방식으로 쿼리를 구현해야 한다


* * *


## **이벤트 저장소 구현**


### **이벤트 저장소**
- 이벤트 소싱 애플리케이션이 이벤트를 저장하는 곳으로 DB와 메시지 브로커를 합한 것
- 애그리거트의 이벤트를 기본키로 삽입 / 조회하는 API와 이벤트를 구독하는 API로 구성
- RDBMS 에 이벤트를 저장하는 방식으로 직접 구현 가능하지만 이벤트 구독기가 모든 이벤트를 순서대로 처리하도록 보장하는 것이 중요함
- 전용 이벤트 저장소를 사용
  - 이벤트 스토어 Event Store : 닷넷 기반의 오픈 소스 이벤트 저장소
  - 라곰 Lagom : 라이트벤드 Lightbend 사가 개발한 마이크로서비스 프레임워크
  - 액손 Axon : 이벤트 소싱 및 CQRS를 사용하는 이벤트 주도형 애플리케이션을 위한 오픈 소스 자바 프레임워크
  - 이벤추에이트 Eventuate : 클라우드 서비스인 이벤추에이트 사스 Eventuate Saas 와 아파치 카프카 / RDBMS 기반의 오픈 소스 프로젝트인 이벤추에이트 로컬 Eventuate Local 이 있음


### **이벤추에이트 로컬**
- 이벤추에이트 로컬 아키텍처
  - 이벤트 DB : 이벤트를 저장하는 MySQL 등의 DB
  - 이벤트 브로커 : 구독기에 이벤트를 전달하는 아파치 카프카 등의 메시지 브로커
  - 이벤트 릴레이 : 이벤트 DB에 저장된 이벤트를 이벤트 브로커에 발행하는 트랜잭션 로그 테일링 장치
- 이벤트 DB 스키마
  - EVENTS : 이벤트를 저장하는 테이블. triggering_event 컬럼을 중복 이벤트/메시지를 발견하는 용도로 사용한다
  - ENTITIES : 엔터티를 하나의 로우로 저장하는 테이블. 엔터티별 현재 버전을 저장하여 낙관적 잠금을 구현한다
  - SNAPSHOTS : 엔터티별 스냅샷을 저장하는 테이블. entity_type 과 entity_id 컬럼으로 스냅샷 엔터티를 지정하고, entity_version 으로 엔터티의 버전을 나타낸다. snapshot_json 컬럼은 스냅샷을 직렬화한 표현형이고 snapshot_type 은 그 타입을 나타낸다.
  - find() 작업 : SNAPSHOTS 테이블에서 가장 최근 스냅샷을 조회한 후, 스냅샷이 존재하면 EVENTS 테이블을 뒤져 스냅샷의 entity_version 보다 크거나 같은 이벤트를 모두 찾고, 스냅샷이 존재하지 않으면 주어진 엔터티의 이벤트를 모두 조회한다
  - create() 작업 : ENTITIES 테이블에 새 로우를 삽입하고 EVENTS 테이블에 이벤트를 삽입한다
  - update() 작업 : EVENTS 테이블에 이벤트를 삽입하고, ENTITIES 테이블에 있는 엔터티 버전을 업데이트해서 낙관적 잠금 체크를 수행한다
- 이벤트 브로커
  - 서비스는 아파치 카프카로 구현된 이벤트 브로커의 토픽을 구독해서 이벤트를 소비함
  - 이벤트 브로커에는 애그리거트 종류마다 토픽이 존재
  - 토픽은 애그리거트 ID를 파티션 키로 사용하는 파티셔닝된 메시지 채널로 구성되어 컨슈머는 애그리거트가 발행한 이벤트 순서를 유지한 상태로 수평 확장이 가능함
- 이벤트 릴레이
  - 이벤트 DB에 삽입된 이벤트를 이벤트 브로커로 전파하기 위해 가능한 한 트랜잭션 로그 테일링을 이용하고 다른 DB를 폴링하기도 함
  - EVENTS 테이블에 이벤트가 삽입되면 해당 아파치 카프카 토픽으로 발행되고, 다른 종류의 변경은 이벤트 릴레이가 그냥 무시함
  - 이벤트 릴레이는 스탠드얼론 프로세스로 배포되고, 정확하게 재시작하기 위해 주기적으로 binlog 에서 현재 위치를 읽어 아파치 카프카 전용 토픽에 저장하여 시동 시 토픽에서 가장 마지막에 기록된 위치를 조회한 후 binlog에서 해당 위치부터 읽기 시작함


### **이벤추에이트 클라이언트 자바 프레임워크**
- 이벤추에이트 로컬 이벤트 저장소를 사용하는 이벤트 소싱 애플리케이션 개발 프레임워크로 이벤트 소싱 기반의 애그리거트, 서비스, 이벤트 핸들러 개발에 필요한 기반을 제공
- 애그리거트 추상 클래스 ReflectiveMutableCommandProcessingAggregate
  - 애그리거트 구상 클래스 및 애그리거트 커맨드 클래스의 상위 클래스를 매개변수로 받는 제네릭 클래스
  - 리플렉션을 이용하여 커맨드를 process()에, 이벤트를 apply()에 디스패치함
- 커맨드 인터페이스 Command
  - 애그리거트 커맨드 인터페이스는 Command 인터페이스를 상속하며, 각각의 애그리거트 커맨드 클래스는 애그리거트 커맨드 인터페이스를 구현한다
  - ```java
  public interface AggregateCommand extends Command {
    ...
  } 
  public class CreateAggregateCommand implements AggregateCommand { 
    ... 
  }
  ```
- 이벤트 인터페이스 Event
  - 애그리거트 이벤트 인터페이스는 마커 인터페이스인 Event 인터페이스를 상속하며, 각각의 애그리거트 이벤트 클래스는 애그리거트 이벤트 인터페이스를 구현한다
  - ```java
  interface AggregateEvent extends Event {
    ...
  } 
  public class AggregateCreated implements AggregateEvent { 
    ... 
  }
  ```
- AggregateRepository 클래스
  - 애그리거트 클래스, 애그리거트의 기초 커맨드 클래스를 타입 매개변수로 받는 제네릭 클래스
  - 애그리거트를 생성, 검색, 수정하는 기능을 제공하고 주로 외부 요청에 대한 응답으로 애그리거트를 생성 / 수정하는 서비스에 쓰임
  - save() : 애그리거트를 생성하는 메서드로 커맨드 객체를 매개변수로 받아, 기본 생성자로 애그리거트 인스턴스를 만들고, process()를 호출하여 커맨드를 처리한 후, apply()를 호출하여 생성된 이벤트를 적용하고, 이벤트 저장소에 저장함
  - update() : 애그리거트를 수정하는 메서드로 애그리거트 ID, 커맨드를 매개변수로 받아, 이벤트 저장소에서 애그리거트를 조회하고, process()를 호출하여 커맨드를 처리한 후, apply()를 호출하여 생성된 이벤트를 적용하고, 이벤트 저장소에 저장함
  - find() : 애그리거트를 검색하는 메서드
- Event Subscriber 애너테이션
  - 애너테이션 방식으로 이벤트 핸들러 작성에 필요한 API를 제공
  - 이벤트 핸들러는 이벤트 및 관련 메타데이터가 포함된 EventHandlerContext 형 매개변수를 받음
  - @EventSubscriber : 클래스 단위 애너테이션으로 이벤트를 처리할 스프링 빈을 지정
  - @EventHandlerMethod : 메서드 단위 애너테이션으로 지정된 메서드를 이벤트 핸들러로 식별


* * *


## **사가 연계**


### **이벤트 소싱과 사가**
- 이벤트 소싱에서는 코레오그래피 사가를 쉽게 이용할 수 있다
- 이벤트 저장소를 사용하는 애플리케이션은 트랜잭션 개념이 상당히 제한적이어서 오케스트레이션 사가와 연계하는 데 주의가 필요하다
- 오케스트레이션 사가의 다음 단계는 반드시 원자적으로 수행되어야 한다
  - 사가 생성 : 사가를 시작한 서비스는 원자적으로 애그리거트를 생성 / 수정하고 사가 오케스트레이터를 생성해야 한다
  - 사가 오케스트레이션 : 사가 오케스트레이터는 원자적으로 응답을 소비하고, 자신의 상태를 업데이트한 후 커맨드 메시지를 전송해야 한다
  - 사가 참여자 : 사가 참여자는 원자적으로 메시지를 소비하고, 중복 메시지를 솎아 내고, 애그리거트를 생성 / 수정하고, 응답 메시지를 전송해야 한다
- 이벤트 저장소의 RDBMS / NoSQL 사용 여부는 이벤트 소싱과 오케스트레이션 사가의 연계 가능성을 가늠하는 핵심 기준이다
  - RDBMS 기반의 이벤트 저장소를 사용하는 애플리케이션은 이벤트 저장소를 ACID 트랜잭션으로 업데이트할 수 있어 오케스트레이션 사가와 연계가 쉽다
  - NoSQL DB를 쓰는 이벤트 저장소는 사가 참여 시 원자성을 유지할 수 있는 다른 방법이 필요하다


### **코레오그래피 사가 구현**
- 이벤트 소싱은 속성상 이벤트가 모든 것을 주도하므로 코레오그래피 사가를 아주 쉽게 구현할 수 있다
- 애그리거트가 업데이트되면 사가가 이벤트를 발생시키고, 이벤트 핸들러는 해당 이벤트를 소비한 후 애그리거트를 업데이트한다. 이벤트 핸들러가 해당 애그리거트를 업데이트하면 또 다른 이벤트가 발생한다.
- 이벤트 소싱은 메시징 기반의 IPC, 메시지 중복 제거, 원자적 상태 업데이트와 메시지 전송 등 사가가 필요로 하는 여러 메커니즘을 제공한다
- 코레오그래피 사가에 이벤트 소싱을 사용하면 애그리거트는 상태 변화가 없어도 무조건 이벤트를 발생시켜야 사가가 진행되는 문제가 있다


### **오케스트레이션 사가 생성**
- 일부 서비스 메서드는 애그리거트를 생성 / 수정하고 사가 오케스트레이터를 생성하는 두 가지 작업을 한다
- 두 작업은 하나가 수행되면 다른 하나는 최종적으로 eventually 실행되는 방식으로 수행된다
- RDBMS 이벤트 저장소 사용 서비스 
  - 이벤트 저장소를 업데이트하고 사가 오케스트레이터를 생성하는 작업을 한 트랜잭션으로 묶어서 동일한 ACID 트랜잭션에 참여하도록 한다
- NoSQL 이벤트 저장소 사용 서비스 
  - 애그리거트가 발생시킨 도메인 이벤트에 반응하여 사가 오케스트레이터를 생성하는 이벤트 핸들러를 작성한다
  - 중복 이벤트를 처리하기 위해서 이벤트를 발생시킨 애그리거트 ID 나 이벤트 ID를 사가 ID로 사용한다
  - 이벤트 주도 방식으로 사가를 생성하는 방식은 RDBMS 이벤트 저장소를 사용하는 서비스에서도 사용 가능하다


### **사가 참여자 구현**
- RDBMS 이벤트 저장소를 이용한 사가 참여자
  - 사가 커맨드 메시지 처리 트랜잭션의 일부로 이벤트 저장소를 업데이트 한다
- NoSQL 이벤트 저장소를 이용한 사가 참여자(트랜잭션이 분리된 경우)
  - 중복 메시지 처리 : 메시지를 처리할 때 생성되는 이벤트에 메시지 ID를 기록하여 다음에 애그리거트를 업데이트 하기 전에 메시지를 처리한 적 있는지 확인한다
  - 응답 메시지 전송 : 사가 오케스트레이터가 단순히 사가 참여자의 도메인 이벤트를 구독하게 하면 애그리거트의 상태 변경이 없는 경우 이벤트가 발생하지 않는 문제가 생기고, 사가 오케스트레이터가 자신의 응답 채널 뿐만 아니라 사가 참여자의 이벤트 채널도 함께 구독해야 하는 문제가 있다 
  - 사가 참여자의 사가 커맨드 핸들러는 애그리거트를 생성 / 수정할 때, 애그리거트가 발생시킨 진짜 이벤트와 가짜 이벤트 SagaReplyRequested를 모두 이벤트 저장소에 저장하고, SagaReplyRequested 이벤트 핸들러는 이벤트에 포함된 데이터로 응답 메시지를 만들어 사가 오케스트레이터의 응답 채널에 출력한다 


### **사가 오케스트레이터 구현**
- 사가 오케스트레이터 저장
  - 사가 오케스트레이터의 상태 재구성에 필요한 데이터를 갖고 있는 두 이벤트로 사가 오케스트레이터를 저장한다
  - SagaOrchestratorCreated 이벤트 : 사가 오케스트레이터 생성 이벤트 
  - SagaOrchestratorUpdated 이벤트 : 사가 오케스트레이터 수정 이벤트
- 원자적 커맨드 메시지 전송
  -  RDBMS 이벤트 저장소 사용 시 커맨드 메시지를 메시지 테이블에 삽입하는 작업을 한 트랜잭션으로 수행한다
  - NoSQL 이벤트 저장소 사용 시 전송할 커맨드를 나타낸 SagaCommandEvent 를 발생시켜 이벤트 저장소에 저장하고, 이벤트 핸들러가 이 이벤트를 구독해서 적절한 채널로 각 커맨드 메시지를 전송한다
  - SagaCommandEvent 의 ID 를 커맨드 메시지 ID로 사용하면 사가 참여자는 중복된 커맨드 메시지를 걸러낼 수 있다
- 중복된 응답 메시지 처리
  - 사가 오케스트레이터가 응답 메시지 ID를 이벤트에 보관하면 중복된 응답 메시지를 걸러낼 수 있다
