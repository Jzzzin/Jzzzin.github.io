---
layout: default
title: Business Logic
parent: Business Logic
grand_parent: Micro Service Architecture Pattern
nav_order: 1
---

# Business Logic
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **비즈니스 로직 구성 패턴**


### **트랜잭션 스크립트 패턴**
- 비즈니스 로직을 요청 타입별로 하나씩 매핑된 절차적 트랜잭션 스크립트 뭉치로 구성
- 동작 behavior 이 구현된 클래스와 상태 state 를 보관하는 클래스가 따로 존재
- 동작이 구현된 서비스 클래스는 각 요청 및 시스템 작업 마다 대응되는 메서드를 갖고, 엔터티 클래스에 상태를 보관한다 
- 객체 지향 프로그래밍 언어의 기능에 거의 의존하지 않는다
- 클래스를 어떻게 구성할지 고민하지 않고 단순하게 코딩할 수 있어 단순한 비즈니스 로직 구현 시 사용
- 비즈니스 로직이 복잡해지면 거의 관리 불가능한 상태로 악화되고 점점 비대해지는 문제점이 있음


**> 비즈니스 로직을 서비스 클래스 하나에 모두 구현하는 방식**
{: .no_toc .text-gamma }


### **도메인 모델 패턴**
- 제각기 문제 영역 problem domain 개념에 직접 대응되는 비교적 작은 클래스가 그물망처럼 얽힌 객체 모델로 구성
- 대부분의 클래스는 상태와 동작을 모두 갖고 있음
- 서비스 클래스는 DB에서 도메인 객체를 로드하고 시스템 작업을 비즈니스 로직이 포함된 도메인 객체에 위임한다
- 도메인 클래스의 상태 값은 프라이빗하고 메서드를 통한 간접 접근만 가능하다
- 소수의 책임만 맡은 작은 여러 클래스로 구성되기 때문에 이해 / 관리하기 쉽고, 각 클래스는 독립적으로 테스트할 수 있으며, 잘 알려진 설계 패턴을 응용할 수 있어 확장하기 쉽다
- 도메인 모델이 복잡해지면 비즈니스 객체들의 경계가 불분명하여 비즈니스 객체를 업데이트할 때 비즈니스 규칙을 위반하는 문제가 생길 가능성이 높다


**> 비즈니스 로직을 여러 개의 도메인 객체 클래스에 각각 구현하는 방식**
{: .no_toc .text-gamma }


### **도메인 주도 설계 Domain-Driven Design**
- 복잡한 비즈니스 로직을 개발하기 위해 OOD를 개선한 접근 방식
- 각 서비스는 자체 도메인 모델을 가지며 애플리케이션 전체 도메인 모델의 문제점을 방지할 수 있다
- DDD 에서 도메인 모델 구축에 주로 사용되는 클래스의 역할과 특징
  - 엔터티 entity : 영속적 신원을 가진 객체. 두 엔터티가 속성 값이 동일해도 엄연히 다른 객체를 의미함. ex. 자바에서 @Entity 어노테이션이 붙은 클래스
  - 밸류 객체 value object : 여러 값을 모아 놓은 객체. 속성 값이 동일한 두 밸류 객체는 서로 바꾸어 사용할 수 있음
  - 팩토리 factory : 일반 생성자로 직접 만들기에 복잡한 객체 생성 로직이 구현된 객체 또는 메서드. 인스턴스로 생성할 구상 클래스를 감출 수 있으며, 클래스의 정적 메서드로 구현할 수 있음
  - 리포지터리 repository : 엔터티를 저장하는 DB 접근 로직을 캡슐화한 객체
  - 서비스 service : 엔터티, 밸류 객체에 속하지 않은 비즈니스 로직 구현 객체
  - 애그리거트 aggregate : 한 단위로 취급 가능한 경계 내부의 도메인 객체들로 하나의 루트 엔터티와 하나 이상의 기타 엔터티, 밸류 객체로 구성


### **애그리거트 패턴**
- 비즈니스 로직의 대부분을 애그리거트로 구성하고 나머지는 도메인 서비스와 사가에 위치
- 애그리거트는 도메인 모델을 개별적으로 이해하기 쉬운 덩어리로 분해하고, 작업 범위를 분명하게 설정하여 모든 작업이 애그리거트 단위로 작용하도록 해서 일관성을 유지한다
- 서비스는 리포지터리로 DB에서 애그리거트를 조회하거나, DB에 애그리거트를 저장한다. 간단한 요청은 애그리거트를 직접 업데이트하고, 여러 서비스에 걸친 업데이트 요청은 사가를 생성해서 처리한다
- 애그리거트 규칙
  - 애그리거트 루트만 참조 : 외부 클래스는 애그리거트의 루트 엔터티만 참조할 수 있고 애그리거트 루트 메서드를 통해서만 애그리거트를 업데이트할 수 있다
  - 애그리거트 간 참조는 기본키를 사용 : 애그리거트는 객체 레퍼런스 대신 신원(외래키)으로 서로를 참조해야 느슨하게 결합되고 애그리거트간 경계가 분명해진다
  - 하나의 트랜잭션으로 하나의 애그리거트를 생성 / 수정 : 여러 애그리거트를 생성 / 수정하려면 사가를 사용한다
- 애그리거트 크기 : 애그리거트의 크기가 작으면 동시 처리 가능한 요청 개수가 늘고 확장성이 좋아지며 애그리거트 업데이트 시 충돌 가능성이 줄기 때문에 가급적 잘게 나누는 fine-grained 것이 좋다


**> 비즈니스 로직을 애그리거트 단위로 구현하는 방식**
{: .no_toc .text-gamma }


* * *


## **도메인 이벤트 패턴**


### **도메인 이벤트**
- 애그리거트에 발생한 사건을 도메인 모델 클래스로 표현한 것으로 대부분 어떤 상태 변경을 나타냄
- 도메인 이벤트 패턴 : 애그리거트의 상태가 전이될 때마다 이에 관련된 컨슈머를 위해 도메인 이벤트를 발행하는 것
- 도메인 이벤트 발행이 사용되는 상황
  - 코레오그래피 사가를 이용하여 여러 서비스에 걸쳐 데이터 일관성을 유지하는 경우
  - 레플리카를 둔 서비스에 소스 데이터가 변경되었음을 알리는 경우
  - 미리 등록된 웹훅 webhook 이나 메시지 브로커를 통해 비즈니스 프로세스의 다음 단계를 진행하도록 다른 애플리케이션에 알리는 경우
  - 사용자 브라우저에 웹 소켓 메시지를 보내거나, 일래스틱서치 같은 텍스트 DB를 업데이트 하기 위해 다른 컴포넌트에 알리는 경우
  - 사용자에게 텍스트 메시지나 이메일로 알리는 경우
  - 애플리케이션이 제대로 작동하고 있는지 모니터링하는 경우
  - 사용자 행동을 모델링하기 위해 이벤트를 분석하는 경우


### **도메인 이벤트 클래스**
- 과거 분사형 동사로 명명 ex. *Created
- 이벤트의 의미를 나타내는 원시 값 primitive value 또는 밸류 객체 value object 프로퍼티 와 이벤트 ID, 타임스탬프 같은 메타데이터, 감사 audit 용도로 사용되는 변경 사용자 신원 정보를 가진다
- 이벤트 강화 event enrichment
  - 이벤트를 처리하는 컨슈머에 필요한 정보를 이벤트가 갖고 다니는 기법
  - 이벤트 컨슈머가 서비스를 쿼리할 필요가 없어서 컨슈머가 간단해지고 오버헤드를 줄일 수 있다
  - 컨슈머 요건이 바뀌면 이벤트 클래스도 바꾸어야 하므로 이벤트 클래스의 안정성 및 유지보수성이 떨어진다


### **도메인 이벤트 식별**
- 이벤트 스토밍 event storming 
  - 복잡한 도메인을 이해하기 위해 이벤트 중심으로 워크숍을 하는 방법
  - 이벤트 브레인스토밍 event brainstorming : 도메인 이벤트를 식별하고 모델링 화면에 대략 그려 놓은 타임라인에 배치한다
  - 이벤트 트리거 event trigger 식별 : 사용자 액션, 외부 시스템, 기타 도메인 이벤트, 시간 경과 같은 각각의 이벤트를 일으키는 트리거를 식별한다
  - 애그리거트 식별 : 각 커맨드 작업 후 적절한 이벤트를 발생시키는 애그리거트를 식별해서 표시한다


### **도메인 이벤트 생성 및 발행, 소비**
- 도메인 이벤트는 애그리거트가 생성하고 서비스가 발행한다 (애그리거트가 발행하지 않는다)
- 애그리거트가 도메인 이벤트를 서비스에 반환하는 방법
  - 애그리거트 메서드 반환값에 이벤트 목록을 넣어서 반환하면 서비스가 애그리거트 루트 메서드 호출 후 이벤트를 받아서 발행
  - 애그리거트 루트의 특정 필드에 이벤트를 쌓아두고 서비스가 애그리거트 루트에서 이벤트를 가져다 발행
- 서비스는 도메인 이벤트를 확실하게 발행하기 위해서 DB 업데이트 트랜잭션의 일부로 이벤트를 DB에 삽입하는 트랜잭셔널 메시징을 사용한다
- 컨슈머는 메시지 브로커에 발행된 도메인 이벤트를 적절한 핸들러를 구현하여 처리한다
