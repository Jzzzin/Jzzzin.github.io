---
layout: default
title: Production Ready
parent: Micro Service Architecture Pattern
nav_order: 8
---

# Production Ready
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


**cf.마이크로서비스에서 품질 속성 관련 이슈**
{: .no_toc .text-gamma }
- 애플리케이션 보안 security : 서비스 간에 사용자 신원을 전달하는 수단 강구해야 함
- 구성 편의성 service configurability : 서비스 실행 환경마다 다른 네트워크 위치와 각 외부 서비스의 자격증명 같은 구성 프로퍼티 값을 런타임에 서비스에 공급하는 외부화 구성 메커니즘 활용해야 함
- 관측성 observability : 분산된 서비스 중 문제가 발생했을 때 원인을 찾을 수 있도록 애플리케이션의 동작을 쉽게 파악할 수 있어야 함  


## **보안 서비스**

### **보안 요소**
- 인증 authentication 
  - 애플리케이션에 접근하는 애플리케이션이나 사람 등의 주체 principal 의 신원을 확인하는 것
  - 사용자 ID / 패스워드나 애플리케이션 API 키 / 시크릿 등을 자격증명으로 확인
- 인가 authorization
  - 주체가 어떤 데이터에 어떤 작업을 요청하여 수행할 수 있는 권한이 있는지 확인하는 것
  - 역할 기반 role-based 보안 및 ACL Access Control List 접근 제어 리스트를 함께 사용
  - 역할 기반 보안 : 사용자마다 하나 이상의 역할을 배정해서 특정 작업의 호출 권한을 부여하는 것
  -  ACL : 사용자 또는 역할을 대상으로 특정 비즈니스 객체나 애그리거트에 작업할 권한을 부여하는 것
- 감사 auditing
  - 보안 이슈 탐지, 컴플라이언스 compliance 시행, 고객 지원을 위해 주체가 수행하는 작업을 추적하는 것
  - 컴플라이언스 : 법규준수 / 준법감시 / 내부통제 등을 의미
- 보안 IPC
  - 모든 서비스를 드나드는 통신이 TLS Transport Layer Security 전송 계층 보안을 경유하는 것이 이상적
  - 서비스 간 통신에 인증이 필요한 경우도 있음


### **모놀리식 애플리케이션의 보안**
- 클라이언트는 최초 로그인 시 세션 토큰(쿠키)를 획득하고 그 다음부터는 세션 토큰을 넣어 요청하는 방식으로 보안을 구현하며 보통 보안 프레임워크를 사용
- 보안 프레임워크
  - 스프링 시큐리티 Spring Security : 자바 애플리케이션에 많이 쓰이는 프레임워크로 스프링 시큐리티의 선언형 declarative 보안 메커니즘은 사용자 종류마다 역할을 정의하고 역할별로 서비스 및 URL 접근을 제한함
  - 아파치 시로 Apache Shiro : 자바 기반 프레임워크
  - 패스포트 Passport : Node.js 에서 유명한 보안 프레임워크
- 세션 session
  - 주체의 ID와 역할을 보관하는 객체로 자바 애플리케이션의 경우 HttpSession 객체를 메모리에서 관리함
  - 암호화된 세션 토큰 session token 으로 식별하며 세션토큰은 보통 JSESSIONID 같은 HTTP 쿠키로 처리
- 보안 컨텍스트 security context
  - 현재 요청을 보낸 사용자 정보를 보관하는 객체
  - 스프링 시큐리티 프레임워크에서는 정적 스레드 로컬 thread-local 변수에 저장되어 모든 요청 핸들러가 현재 사용자의 신원 / 역할 등 모든 정보를 SecurityContextHolder.getContext().getAuthentication() 으로 획득할 수 있음
  - 패스포트 프레임워크에서는 request의 user 속성으로 보관함
- 보안 이벤트 처리 순서
  - 클라이언트가 애플리케이션에 로그인 요청
  - 로그인 핸들러 LoginHandler 가 자격증명 확인, 세션 생성, 세션에 주체 정보 저장 등 일련의 로그인 요청 처리를 수행하고 클라이언트에 세션 토큰을 반환
  - 클라이언트는 이후 모든 작업을 호출할 때마다 세션 토큰을 넣어 보냄
  - SessionBasedSecurityInterceptor 가 요청이 들어올 때마다 세션 토큰을 확인한 후 주어진 세션의 사용자 정보를 조회하여 주체와 역할 관련 정보가 들어있는 보안 컨텍스트를 설정
  - 요청 핸들러는 보안 컨텍스트를 이용하여 사용자가 작업을 수행할 권한이 있는지 판단하고 사용자의 신원을 획득
- 인-메모리 세션의 단점
  - 특정 세션의 요청을 모두 동일한 애플리케이션 인스턴스로 라우팅해야 되므로 부하 분산 및 작업을 복잡하게 만듬
  - 애플리케이션 인스턴스를 닫기 전에 모든 세션이 만료되길 기다리는 세션 배수 session draining 매커니즘을 구현해야 함
  - DB에 세션을 저장하여 우회하거나, 매 요청마다 API 키 / 시크릿 등 자격증명을 제공하도록 하여 서버 쪽 세션을 아예 없애거나, 세션 토큰에 세션 상태를 저장하는 방법을 사용


### **마이크로서비스의 보안 이슈**
- 모든 외부 요청을 API 게이트웨이와 하나 이상의 서비스가 처리하는 분산 시스템이므로 보안을 구현하려면 사용자의 인증 / 인가 처리를 누가 담당할지부터 결정해야 함
- 서로 다른 서비스는 메모리를 공유할 수 없으므로 스레드 로컬 등 인-메모리 보안 컨텍스트 in-memory security context 를 이용해서 사용자 신원을 전달할 수 없음
- 중앙화 세션 centralized session도 인-메모리 보안 컨텍스트와 마찬가지로 사용 불가능하지만 이론상 여러 서비스가 DB 기반의 세션에 접근하는 것은 가능함
- 마이크로서비스 아키텍처의 기본 보안 사상
  - API 게이트웨이는 클라이언트 인증을 담당
  - API 게이트웨이 및 서비스는 투명 토큰을 이용하여 주체 정보를 주고 받음
  - 서비스는 토큰을 이용하여 주체의 신원 / 역할 정보를 획득


### **인증 처리 : 액세스 토큰 패턴**
- API 게이트웨이가 요청을 인증하고 신원, 역할 등 사용자 정보가 담긴 토큰을 자신이 호출하는 서비스에 전달하는 패턴
- API 게이트웨이에 인증 로직을 중앙화하면 보안 취약점이 노출될 가능성이 줄어들고 클라이언트마다 제각각인 다양한 인증 메커니즘을 전담해서 처리하므로 복잡한 코드를 서비스에서 감출 수 있다
- API 게이트웨이가 매번 서비스에 요청을 할때마다 토큰을 함께 넣어 보내면 서비스는 이 토큰을 이용하여 요청을 검증하거나 주체 정보를 획득한다
- API 클라이언트 인증 이벤트 순서
  - 클라이언트는 자격증명이 포함된 요청을 전송
  - API 게이트웨이는 자격증명을 인증하고, 보안 토큰을 생성해서 서비스(들)에 전달
- 로그인 기반 클라이언트 인증 이벤트 순서
  - 클라이언트는 자격증명이 포함된 로그인 요청을 함
  - API 게이트웨이는 보안 토큰을 반환
  - 클라이언트는 작업을 호출하는 요청에 보안 토큰을 넣어 보냄
  - API 게이트웨이는 보안 토큰을 검증하고 해당 서비스(들)로 포워딩


### **인가 처리**
- API 게이트웨이가 요청을 서비스에 포워딩하기 전에 권한 없는 사용자가 특정 경로에 접근하는 것을 제한하는 인가 처리를 하면 보안을 강화할 수 있음
- API 게이트웨이에 인가 로직을 두면 API 게이트웨이와 서비스가 단단히 결합하게 되고, URL 경로 접근 제어만 구현할 수 있어 개별 도메인 객체의 접근 권한을 제어하는 ACL 까지 구현하기는 무리임
- 서비스가 직접 역할 기반으로 URL과 메서드를 인가하고, ACL로 애그리거트 접근을 따로 관리하는 것이 좋음


### **사용자 신원 / 역할 전달**
- API 게이트웨이가 사용자 정보를 담아 서비스에 전달할 토큰의 종류를 결정해야 함
- 난독화 토큰 opaque token
  - UUID Universally Unique Identifier 범용 고유 식별자를 사용
  - 토큰 수신자가 토큰의 유효성을 검증하고 사용자 정보를 조회하기 위해 보안 서비스를 동기 RPC 호출하기 때문에 성능 및 가용성이 떨어지고 지연시간이 길다
- 투명 토큰 transparent token
  - 두 당사자 간의 사용자 신원 / 역할 등의 정보를 안전하게 표현하는 표준 수단인 JWT JSON Web Token 을 사용
  - 사용자 정보, 만료일자 등 각종 메타데이터가 포함된 JSON 객체를 페이로드 payload 에 담아 JWT 생성자와 JWT 수신자만 알 수 있는 시크릿으로 서명하여 사용하므로 보안 서비스 호출이 필요없고 악의적인 제삼자가 JWT를 위변조하기는 거의 불가능함
  - 서비스가 JWT 서명과 만료일자를 확인 후 요청받은 작업을 수행하는 구조라서 토큰 자체가 악의적인 해커에 넘어가더라도 이를 취소할 방법이 없음
  - 유효 기간이 짧은 JWT를 발급하여 JWT가 탈취되어도 뭔가 해볼 수 있는 시간을 제약할 수 있지만 애플리케이션이 세션을 유지하기 위해 계속 JWT를 재발행해야 함


### **OAuth 2.0**
- 깃허브나 구글 등 퍼블릭 클라우드 서비스 사용자가 자기 정보에 접근하려는 서드파티 애플리케이션을 패스워드 노출 없이 허가할 수 있는 방안을 찾다가 정착된 인증 프로토콜
- OAuth 2.0 핵심 개념
  - 인증 서버 Authorization Server : 사용자 인증 및 액세스 / 리프레시 토큰 획득 API를 제공하며, 스프링 OAuth 프레임워크로 구축 
  - 액세스 토큰 Access Token : 리소스 서버 접근을 허가하는 토큰으로 구현체마다 포맷이 다르며, 스프링 OAuth는 JWT를 사용
  - 리프레시 토큰 Refresh Token : 클라이언트가 새 액세스 토큰을 얻기 위해 필요한 토큰으로 수명은 길지만 취소 가능한 revocable 토큰임
  - 리소스 서버 Resource Server : 액세스 토큰으로 접근을 허가하는 서비스로 마이크로서비스 아키텍처에서는 서비스가 곧 리소스 서버임
  - 클라이언트 : 리소스 서버에 접근하려는 클라이언트로 마이크로서비스 아키텍처에서는 API 게이트웨이가 OAuth 2.0 클라이언트임
- API 클라이언트 인증 이벤트 순서
  - API 클라이언트는 기본 인증을 이용하여 자격증명과 함께 요청
  - API 게이트웨이는 OAuth 2.0 인증 서버에 패스워드 승인 Password Grant 을 요청
  - 인증 서버는 API 클라이언트의 자격증명을 검증하고 액세스 / 리프레시 토큰을 반환
  - API 게이트웨이는 서비스에 요청을 할 때마다 발급받은 액세스 토큰을 넣어 보냄
  - 서비스는 액세스 토큰을 이용하여 요청을 인증
- 로그인 기반 클라이언트 인증 이벤트 순서
  - 로그인 기반 클라이언트가 자격증명을 API 게이트웨이에 POST함
  - API 게이트웨이의 로그인 핸들러는 OAuth 2.0 인증 서버에 패스워드 승인을 요청
  - 인증 서버는 클라이언트의 자격증명을 검증 후 액세스 / 리프레시 토큰을 반환
  - API 게이트웨이는 인증 서버에서 받은 두 토큰을 클라이언트에 쿠키 포맷 등으로 반환
  - 클라이언트는 액세스 / 리프레시 토큰을 API 게이트웨이에 요청할 때마다 실어 보냄
  - API 게이트웨이의 세션 인증 인터셉터 session authentication interceptor 는 액세스 토큰을 검증 후 서비스에 토큰을 넣어 보냄 
- 액세스 토큰 재발급 순서
  - 액세스 토큰이 이미 만료 또는 거의 만료된 경우 API 게이트웨이는 인증 서버에 OAuth 2.0 리프레시 승인 Refresh Grant을 요청
  - 리프레시 토큰이 만료 / 해지 전이라면 인증 서버는 액세스 토큰을 새로 만들어 반환
  - API 게이트웨이는 새 액세스 토큰을 서비스에 전달하고 클라이언트에 반환
- OAuth 2.0은 널리 검증된 보안 표준이어서 보안을 구현하는 시간을 단축할 수 있고 안전한 보안 시스템을 개발할 수 있다


* * *


## **구성 가능한 서비스**


### **외부화 구성 패턴**
- 런타임에 DB 자격증명, 네트워크 위치 등 구성 프로퍼티 값을 서비스에서 제공하는 패턴
- 스프링 프레임워크의 프로파일 profile 장치로 런타임에 프로퍼티 세트를 선택하는 구조는 보안에 취약하고 배포에 한계가 있다
- 자격증명처럼 민감한 데이터는 해시코프 볼트 Hashicorp Vault 나 AWS 파라미터 스토어 같은 보안 저장 장치로 안전하게 저장되어야 한다
- 배포 파이프라인을 통해 같은 서비스를 여러 환경에 한 번에 배포할 수 있도록 서비스 실행 환경마다 다른 구성 프로퍼티 값을 외부화 구성 패턴으로 런타임에 서비스에 제공한다


### **푸시 모델 push model**
- OS 환경 변수, 구성 파일 등을 통해 배포 인프라에서 서비스로 프로퍼티 값을 전달하는 방식
- 배포 환경이 서비스 인스턴스가 생성될 때 프로퍼티 값을 제공하므로 배포 환경과 서비스가 프로퍼티 값을 주고받는 방법을 서로 맞추어야 한다
- 스프링 부트가 프로퍼티 값을 읽어 올 수 있는 소스
  - CLI 인수
  - JSON 포맷으로 기술된 OS 환경 변수 또는 JVM 시스템 프로퍼티
  - JVM 시스템 프로퍼티
  - OS 환경 변수
  - 현재 디렉터리의 구성 파일
  - cf. 프로퍼티명이 똑같을 경우 위에서부터 우선 적용되고 구성 프로퍼티 값은 @Value 를 붙여 스프링 프레임워크의 ApplicationContext로 가져옴
- 이미 실행 중인 서비스의 외부화 구성은 서비스를 재시동하지 않고서는 재구성하기 어려운 한계가 있고, 구성 프로퍼티 값이 여러 서비스에 흩어지는 문제가 있음 


### **풀 모델 pull model**
- 서비스 인스턴스가 시동 시 구성 서버에 접속해서 프로퍼티 값을 읽어 오는 방식 
- 구성 서버 접속에 필요한 프로퍼티 값은 배포 인프라가 환경 변수 등의 푸시 구성 메커니즘을 통해 서비스 인스턴스에 제공
- 구성 서버 종류
  - 깃, SVN 등 버전 관리 시스템 
  - SQL / NoSQL DB
  - 스프링 클라우드 컨피그 서버 등 전용 구성 서버
  - 자격증명 등 민감한 데이터를 보관하는 해시코프 볼트, AWS 파라미터 스토어
- 스프링 클라우드 컨피그 Spring Cloud Config
  - 서버 / 클라이언트로 구성된 구성 서버 기반 프레임워크
  - 서버는 버전 관리 시스템, DB, 해시코프 볼트 등 구성 프로퍼티를 저장하는 다양한 백엔드 기술을 지원
  - 클라이언트는 서버에서 구성 프로퍼티를 가져와 스프링 ApplicationContext에 주입하는 역할을 함
- 구성 서버의 장점
  - 중앙화 구성 centralized configuration : 모든 구성 프로퍼티를 한곳에서 관리하므로 간편하고, 전역 기본값을 정의해서 서비스 단위로 재정의하는 식으로 중복 구성 프로퍼티를 제거할 수 있음
  - 민감한 데이터의 투명한 복호화 transparent decryption : DB 자격증명 등 민감한 데이터를 암호화하고 구성 서버가 프로퍼티를 자동 복호화해서 서비스에 전달
  - 동적 재구성 dynamic reconfiguration : 수정된 프로퍼티 값을 폴링 등으로 감지해서 자동 재구성함
- 구성 서버도 설정 / 관리해야 하는 부가적인 인프라 요소이지만 스프링 클라우드 컨피그 등 오픈 소스 프레임워크를 사용하면 크게 부담스럽지 않다


* * *


## **관측 가능한 서비스**


### **관측성 패턴**
- 개발 / 운영자가 애플리케이션 동작을 이해하고 트러블슈팅할 수 있게 도와주는 관측 가능한 서비스를 설계하는 패턴
- 개발자는 서비스가 확실하게 관측될 수 있게 하고, 운영자는 서비스가 표출한 정보를 수집하는 인프라를 운영한다
- 헬스 체크 health check API 패턴, 로그 수집 log aggregation 패턴, 분산 추적 distributed tracing 패턴, 예외 추적 exception tracking 패턴, 애플리케이션 지표 application metrics 패턴, 감사 로깅 audit logging 패턴 등

 
### **헬스 체크 API 패턴**
- 서비스에 서비스 상태를 반환하는 GET /health 등의 헬스 체크 API endpoint 를 표출하는 패턴
- 서비스 인스턴스는 자신이 요청을 처리할 수 있는 상태인지 여부를 알리는 헬스 체크 endpoint를 구현하고, 배포 인프라는 서비스에 구현된 헬스 체크 endpoint 를 주기적으로 호출해서 서비스 인스턴스 상태를 파악한다
- 헬스 체크 요청 핸들러는 서비스 인스턴스 및 외부 서비스의 접속 상태를 테스트하고, 각 어댑터의 자세한 헬스 정보도 함께 반환한다
- 헬스 체크 endpoint 구현
  - 서비스 인스턴스가 외부 인프라 서비스에 접근 가능한지 확인
  - 스프링 부트 액추에이터 : 자바 진영의 라이브러리로 /actuator/health endpoint 를 호출하면 서비스가 사용하는 인프라를 체크하여 헬스 체크 실행 결과를 반환
  - 헬스체크 HealthChecks : 닷넷 진영의 라이브러리로 /hc endpoint를 제공
- 헬스 체크 endpoint 호출
  - 서비스를 배포할 때 도커 나 쿠버네티스 같은 배포 인프라가 헬스 체크 endpoint를 호출하도록 구성
  - 넷플릭스 유레카 같은 서비스 레지스트리가 헬스 체크 endpoint를 호출하도록 구성

 
### **로그 수집 패턴**
- 전체 서비스 로그를 검색 / 알림 기능이 구현된 중앙 로그 서버에 수집하는 패턴
- 모든 서비스 인스턴스가 남긴 로그를 로그 수집 파이프라인을 통해 중앙 로깅 서버로 보내 간편하게 조회, 검색, 분석할 수 있고, 특정한 메시지가 로그에 있으면 알림을 전송하도록 구성할 수 있다
- 서비스 로그 생성
  - 자바 진영의 로그백 Logback, Log4J, JUL, SLF4J, Node.js 진영의 Log4JS 같은 로깅 프레임워크를 이용하여 로그 항목을 생성
  - 파일 시스템 경로에 로그 파일을 생성하거나 stdout에 로깅
- 로그 수집 인프라
  - 로깅 인프라는 로그를 수집, 저장하고 사용자는 저장된 로그를 검색할 수 있다
  - ELK 스택 stack : 로깅 서버로 쓰이는 텍스트 검색 지향 NoSQL DB인 일래스틱서치 Elasticsearch, 서비스 로그를 수집하여 일래스틱서치에 출력하는 로그 파이프라인인 로그스태시 Logstash, 일래스틱서치 전용 시각화 툴인 키바나Kibana로 구성된 오픈 소스 로깅 인프라 
  - Fluentd나 아파치 플룸 Apache Flume 같은 오픈 소스 로그 파이프라인이나 AWS 클라우드워치 로그 등 상용 제품도 있음
- 로그는 트러블슈팅에 매우 유용하며 로그 수집은 마이크로서비스 아키텍처에서 대단히 유용한 디버깅 툴이다

 
### **분산 추적 패턴**
- 외부 요청마다 유일한 ID를 하나씩 부여해서 한 서비스에서 다음 서비스로 흘러가는 과정을 기록하고, 시각화 / 분석 기능을 제공하는 중앙화 서버에 자료를 남기는 패턴
- 모놀리식 애플리케이션의 성능 프로파일러 performance profiler와 비슷하게 요청을 처리할 때마다 시작 시간, 종료 시간 등의 서비스 호출 트리 정보를 기록함
- 각 요청은 하나의 트레이스 trace 로 표시되며, 트레이스는 하나 이상의 스팬 span으로 구성됨
- 스팬은 작업을 나타내며, 작업명, 시작/종료 타임스탬프를 주요 속성으로 가지고, 중첩된 작업은 하나 이상의 자식 스팬으로 나타냄
- 분산 추적은 각 외부 요청마다 ID를 부여하여 서비스는 요청 ID를 로그에 남길 수 있고, 특정 외부 요청에 대한 로그 항목은 수집된 로그에서 요청 ID로 찾을 수 있음 
- 인스트루멘테이션 라이브러리 instrumentation library
  - 트레이스와 스팬을 관리하여 현재 트레이스 ID, 부모 스팬 ID 등의 추적 정보를 아웃바운드 요청에 추가하고 스팬 트리를 만들어 분산 추적 서버로 보냄
  - 인터셉터나 애스팩트 지향 프로그래밍 AOP를 이용하여 구현
  - 스프링 클라우드 슬루스 Spring Cloud Sleuth : 스프링 프레임워크의 AOP 메커니즘을 이용하여 분산 추적 기능을 서비스에 자동 연계하여 서비스가 분산 추적 API를 직접 호출할 필요가 없음
- 분산 추적 서버
  - 전달 받은 스팬을 서로 짜깁기해서 완전한 트레이스 형태로 만든 후 DB에 저장하고 UI로 시작화하여 표시하는 기능을 제공
  - 트위터가 개발한 오픈 집킨 Open Zipkin이나 AWS 엑스레이가 잘 알려진 분산 추적 서버임 

 
### **애플리케이션 지표 패턴**
- 서비스는 기술 스택의 모든 부분에서 지표를 수집하고 수집한 데이터를 수집, 시각화, 알림 기능을 제공하는 지표 서버에 보고한다
- 지표는 주기적으로 샘플링 sampling 하고, 지표명 name, 수치 값 value, 샘플링 시간 timestamp의 세 가지 속성을 가진다
- 지표 수집 기능 구현
  - 애플리케이션에 사용한 프레임워크와 수집하려는 지표 종류마다 구현 방식이 다르다
  - 스프링 부트 기반의 서비스는 마이크로미터 메트릭스 Micrometer Metrics 라이브러리를 디펜던시로 추가하고 구성 코드만 추가하면 기본 지표는 바로 수집 가능하고, 마이크로미터 메트릭스의 MeterRegistry 인터페이스를 시용하여 사용자 정의 지표를 수집할 수도 있다
- 지표 전달
  - 서비스는 수집한 지표를 푸시 또는 풀 방식으로 메트릭스 서비스에 전달한다
  - 푸시 모델 : 서비스 인스턴스가 API를 호출하여 메트릭스 서비스에 지표를 밀어 넣은 방법 ex. AWS 클라우드 워치
  - 풀 모델 : 메트릭스 서비스 또는 로컬에서 실행되는 에이전트가 서비스 API를 호출하여 서비스 인스턴스에서 지표를 당겨오는 방법 ex. 프로메테우스 Prometheus
  - micrometer-registry-prometheus 라이브러리로 프로메테우스와 연계하면 프로메테우스 서버는 주기적으로 /actuator/prometheus endpoint 를 폴링하여 지표를 가져오고, 프로메테우스에 축적된 지표 데이터는 그라파나 Grafana 라는 시각화 툴로 조회할 수 있다
- 애플리케이션 지표는 애플리케이션의 동작을 파악하는 중요한 단서를 제공하고 알림 기능은 문제가 커지기 전에 신속히 조치할 수 있게 한다

 
### **예외 추적 패턴**
- 서비스는 중복된 예외를 제거하고, 알림을 생성하고, 예외 해결 과정을 관리하는 예외 추적 서비스에 예외를 보고한다
- 서비스에 예외가 발생하면 무조건 예외 추적 서비스에 보고하도록 허니배저 HoneyBadger 나 Sentry.io 같은 예외 추적 서비스에 내장된 클라이언트 라이브러리를 활용한다
- 기존 로그에서 예외를 구분해야 되는 이유
  - 로그 파일은 대부분 한 줄짜리 로그 항목이 많지만, 예외는 보통 여러 줄로 나온다
  - 로그 파일에 있는 예외의 해결 과정을 추적할 메커니즘이 없다
  - 중복된 예외를 자동으로 하나의 예외로 식별하여 처리할 방법이 없다
- 예외 추적은 운영 이슈를 신속하게 발견하여 대응할 수 있게 해준다


### **감사 로깅 패턴**
- 고객 지원, 컴플라이언스 준수, 수상한 동작 감지를 위해 사용자 액션을 기록하는 패턴
- 사용자 신원 및 사용자가 수행한 작업, 비즈니스 객체를 감사 로그 항목에 기록해서 DB에 저장한다
- 감사 로깅 코드를 비즈니스 로직에 추가
  - 서비스 메서드마다 감사 로그 항목을 생성하고 DB에 저장하는 방식
  - 관리하기가 쉽지 않고 에러가 날 가능성도 높다
- 애스팩트 지향 프로그래밍 AOP 활용
  - AOP를 응용해서 각 서비스 메서드의 호출을 자동 인터셉트하는 어드바이스 advice를 스프링 AOP 등의 AOP 프 레임워크로 구성해서 감사 로그 항목을 저장하는 방식
  - 메서드명과 인수만 접근할 수 있기 때문에 어떤 비즈니스 객체를 대상으로 액션이 이루어지는지 판단하거나 비즈니스 지향적인 감사 로그 항목을 만들기 어렵다
- 이벤트 소싱 활용
  - 이벤트 소싱은 생성 / 수정 작업의 감사 로그를 자동으로 제공하는 기능이 있으므로 각각 이벤트에 사용자 신원을 기록하여 저장하는 방식
  - 쿼리는 기록하지 않기 때문에 쿼리를 별도 로그 항목으로 남겨야 할 경우는 다른 방법을 강구해야 함


* * *


## **마이크로서비스 섀시 패턴**


### **마이크로서비스 섀시**
- 예외 추적, 로깅, 헬스 체크, 외부화 구성, 분산 추적 등의 횡단 관심사를 처리하는 프레임워크를 기반으로 서비스를 구축하는 패턴
- 마이크로서비스 섀시는 횡단 관심사 처리에 특화된 프레임워크이므로 마이크로서비스 섀시 기반으로 서비스를 구축하면 횡단 관심사를 처리하는 코드를 서비스에 작성할 일이 거의 없어 개발 속도가 빨라짐
- 스프링 부트, 스프링 클라우드를 마이크로서비스 섀시로 활용하면 외부화 구성 같은 기능은 스프링 부트가, 회로 차단기 같은 기능은 스프링 클라우드가 각각 제공한다
- 고 언어로 작성된 애플리케이션은 고 킷 Go Kit 이나 마이크로 Micro 를 마이크로서비스 섀시로 사용한다
- 서비스를 개발하는 모든 언어 / 플랫폼 조합 마다 마이크로서비스 섀시가 하나씩 필요한 단점이 있다

 
### **서비스 메시 패턴**
- 회로 차단기, 분산 추적, 서비스 디스커버리, 부하 분산, 룰 기반 트래픽 라우팅 등 다양한 관심사가 구현된 네트워킹 계층을 통해 서비스를 드나드는 모든 네트워크 트래픽을 라우팅하는 패턴
- 서비스 메시는 한 서비스와 다른 서비스, 그리고 외부 애플리케이션 간의 소통을 조정하는 인프라로 서비스를 드나드는 네트워크 트래픽은 모두 서비스 메시를 통과한다
- 공통 기능 일부를 서비스 외부에 위치한 서비스 메시에 구현하면 서비스에 직접 구현할 필요가 없고, 서비스 메시는 TLS 기반의 IPC로 서비스 간 IPC를 보안하는 기능도 제공한다
- 서비스 메시를 사용하면 마이크로서비스 섀시는 외부화 구성, 헬스 체크 등 애플리케이션 코드와 단단히 결합된 관심사만 구현하면 된다
- 서비스 메시를 구현한 제품으로는 이스티오 Istio, 링커드 Linkerd, 콘듀이트 Conduit 등이 있다