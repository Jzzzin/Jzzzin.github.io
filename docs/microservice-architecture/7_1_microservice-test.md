---
layout: default
title: Micro Service Test
parent: Micro Service Test
grand_parent: Micro Service Architecture Pattern
nav_order: 1
---

# Micro Service Test
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **MSA 테스트 전략**


### **테스트 개요**
- 수동 테스트는 느리고 비효율적이기 때문에 커밋된 소스 코드가 제품으로 전달되기까지 소요 시간을 줄이려면 반드시 테스트를 자동화해야 한다
- 테스트 케이스 test case : 어떤 목표를 달성하기 위해 개발된 테스트 입력, 실행 조건, 기대 결과의 집합
- 테스트의 목적 : 테스트 대상 시스템 System Under Test 의 동작을 확인하는 것
- 테스트 대상 시스템 SUT : 테스트해야 할 소프트웨어 엘리먼트를 가리키는 용어로 클래스 수준의 작은 단위부터 전체 애플리케이션만큼 큰 단위일 수 있다
- 테스트 스위트 : 서로 연관된 테스트를 모아 놓은 것 


### **자동화 테스트**
- 대부분 JUnit 등의 테스트 프레임워크로 작성한다
- 테스트 러너 runner 를 실행하면 테스트 클래스 내의 테스트 메서드가 SUT를 포함한 테스트 픽스처 test fixture 를 대상으로 테스트를 수행한다
- 자동화 테스트의 구성
  - 설정 setup : SUT와 그 디펜던시로 구성된 테스트 픽스처를 초기화 ex. 테스트 대상 클래스 생성 및 초기화
  - 실행 exercise : SUT를 호출 ex. 테스트 대상 클래스의 메서드를 호출함
  - 확인 verify : 호출 결과 및 SUT 상태를 단언 assertion 함 ex. 메서드 반환값이나 대상 클래스의 새 상태를 확인
  - 정리 teardown : 필요 시 테스트 픽스처를 깨끗이 정리함 ex. DB 트랜잭션을 롤백
  - 코드 중복을 줄이고 테스트를 단순화하기 위해 테스트 메서드 이전에 실행되는 설정 메서드, 테스트 메서드 이후 실행되는 정리 메서드를 테스트 클래스에 따로 둔다
- 테스트 더블 test double
  - 디펜던시의 동작을 흉내 낸 객체
  - SUT 가 갖고 있는 디펜던시를 테스트 더블로 대체하면 SUT 만 따로 테스트할 수 있어서 테스트가 더 간단하고 빨라진다
  - 스텁 stub : SUT 에 값을 반환하는 테스트 더블
  - 목 mock : SUT 가 정확하게 디펜던시를 호출했는지 확인하는 테스트 더블로 스텁의 일종

### **테스트 분류**
- 범위 scope 에 따른 분류
  - 애플리케이션 또는 서비스의 동작 여부를 확인하는 테스트를 대상으로 테스트 범위에 따라 네 가지로 분류
  - 단위 테스트 unit test : 클래스 같은 서비스의 작은 부분을 테스트
  - 통합 테스트 integration test : 애플리케이션 서비스가 DB 등의 인프라 서비스 및 타 애플리케이션 서비스와 잘 연동되어 작동하는지 확인하는 테스트
  - 컴포넌트 테스트 component test : 개별 서비스에 대한 인수 테스트 acceptance test
  - 종단 간 테스트 end-to-end test : 전체 애플리케이션에 대한 인수 테스트
  - cf. 애플리케이션의 서비스 품질 수준을 확인하는 테스트 : 성능 테스트 performance test, 사용성 테스트 usability test
- Test-Driven Development 테스트 주도 개발
  - 신규 기능을 개발하거나 버그를 고칠 때 일단 실패하는 테스트를 작성한 후 그 테스트를 충족하는 코드를 작성하는 방식으로 개발하는 것
  - 컴파일 타임 테스트 compile-time test : 개발 과정의 일부로 실행하는 테스트로 가급적 초 단위로 빠르게 실행되어야 작업 흐름이 끊기지 않는다 
- 테스트 사분면 test quadrant 에 따른 분류
  - 테스트 대상 : 비즈니스 관련 테스트는 도메인 전문가의 용어로, 기술에 관한 테스트는 개발자의 용어를 써서 기술한다
  - 테스트 목적 : 프로그래밍 지원 테스트는 개발 업무의 일부로 사용하고, 애플리케이션 평가 테스트는 개선이 필요한 부분을 식별하기 위해 사용한다
  - Q1 프로그래밍 지원 / 기술 관련 테스트 : 단위 / 통합 테스트로 자동화 테스트
  - Q2 프로그래밍 지원 / 비즈니스 관련 테스트 : 컴포넌트 / 종단 간 테스트로 자동화 테스트
  - Q3 애플리케이션 평가 / 비즈니스 관련 테스트 : 사용성 / 예비 테스트로 수동 테스트
  - Q4 애플리케이션 평가 / 기술 관련 테스트 : 비기능(성능, 보안 등) 인수 테스트로 일부 자동화 및 수동 테스트
- 테스트 피라미드
  - 단위 테스트 부터 종단 간 테스트에 이르는 테스트 유형의 상대적 비중을 피라미드 형태로 나타낸 것
  - 피라미드 하부에는 빠르고 간단하고 미더운 단위 테스트가 위치하고 피라미드 상부는 느리고 복잡하고 취약한 종단 간 테스트가 위치함
  - 상부로 올라갈수록 작성하는 테스트 개수가 줄어들어야 한다


* * *


## **마이크로서비스 테스트**


### **마이크로서비스 테스트 개요**
- 마이크로서비스 기반의 애플리케이션은 팀별로 각자 맡은 서비스를 개발하고 꾸준히 API를 발전시키는 분산 시스템이기 때문에 IPC 의 비중이 크고 연동 테스트가 중요하다
- 서비스 개발자는 자신이 소비하는 서비스의 API가 안정적인지 미리 확인해야 하며, 자신이 제공하는 서비스의 API를 함부로 바꾸지 않도록 주의해야 한다
- 서비스 간의 상호 작용은 서비스를 모두 실행하고 통신을 일으키는 API를 호출한 후 기대한 결과가 나오는지 확인하면 알 수 있지만, 이 방식은 기본적으로 종단 간 테스트 이므로 가능한 한 작성하지 않아야 한다
- 컨슈머 주도 계약 테스트 consumer-driven contract test 를 활용하면 서비스만 따로 떼어 내서 더 빠르고 간단하고 미더운 테스트를 수행할 수 있다


### **컨슈머 주도 계약 테스트 consumer-driven contract test**
- 프로바이더 API의 형상 shape이 컨슈머가 기대한 것과 부합하는지 확인하는 프로바이더에 대한 통합 테스트
- REST endpoint 의 경우
  - 컨슈머가 기대한 HTTP 메서드와 경로로 구현되었는가?
  - 헤더가 있는 경우 컨슈머가 기대한 헤더를 받는가?
  - 요청 본문이 있는 경우 요청 본문을 받는가?
  - 컨슈머가 기대한 상태 코드, 헤더, 본문이 포함된 응답을 반환하는가? 
  - 컨슈머 계약 테스트는 프로바이더의 비즈니스 로직을 빠짐없이 체크하는 테스트가 아니므로, 사실 목 컨트롤러 mock controller 테스트이다
- 컨슈머 주도 계약 테스트 절차
  - 각 컨슈머 개발 팀은 계약 테스트 스위트를 작성한 후 깃 git 풀 리퀘스트 pull request 방식으로 프로바이더의 테스트 스위트에 추가한다
  - 취합된 테스트 스위트는 프로바이더 서비스 배포 파이프라인으로 실행한다
  - 컨슈머 계약 테스트가 실패했다면 프로바이더 팀이 API를 계약에 안 맞게 고쳤다는 뜻이므로 API를 바로잡든가, 컨슈머 팀과 다시 협의한다
- 사례에 의한 테스트 testing by example
  - 컨슈머 / 프로바이더 간 상호 작용을 계약 contract 이라는 샘플 모음집으로 정의
  - 각 계약은 한 번의 상호 작용 도중 주고받는 샘플 메시지로 구성
  - 프로바이더에 샘플 요청을 넘겨 호출하고, 샘플 응답으로 컨슈머가 계약을 준수하는지 확인
- 컨슈머 쪽 계약 테스트 consumer-side contract test
  - 클라이언트가 서비스와 통신 가능한지 확인한다
  - REST 클라이언트의 경우 계약대로 HTTP 요청을 하고 HTTP 응답을 반환하는지 확인하는 HTTP 스텁 서비스를 구성하여 테스트한다
- 컨슈머 주도 계약 테스트로 프로바이더를 테스트하고, 컨슈머 쪽 계약 테스트로 컨슈머를 테스트하여 API가 서로 맞는지 확인한다


### **컨슈머 계약 테스트 프레임워크 : 스프링 클라우드 컨트랙트**
- 스프링 클라우드 컨트랙트 Spring Cloud Contract
  - 스프링 애플리케이션용 컨슈머 계약 테스트 프레임워크로 계약을 그루비 DSL로 작성할 수 있게 지원함
  - 프로바이더의 계약 테스트 코드를 생성하고 컨슈머 통합 테스트용 목을 구성
  - REST API 뿐만 아니라 메시징 API 테스트도 가능함
  - cf. 팩트 Pact 프레임워크군 : 다양한 언어를 지원하는 컨슈머 계약 테스트 프레임워크
- 테스트 절차
  - 컨슈머 개발 팀이 하나 이상의 계약을 작성하여 깃 풀 리퀘스트로 프로바이더 서비스 팀에 전달
  - 프로바이더 서비스 팀은 스프링 클라우드 컨트랙트에서 자동 생성된 테스트 코드로 컨슈머 계약 테스트를 진행
  - 프로바이더 서비스 팀은 테스트한 계약을 메이븐 저장소로 발행
  - 컨슈머 개발 팀은 프로바이더 서비스 팀이 발행한 계약을 이용하여 컨슈머 테스트를 작성
  - 프로바이더 서비스 팀이 발행한 계약으로 컨슈머를 테스트하기 때문에 신뢰도가 높다
- HTTP 요청 / 응답 계약
  - 요청 / 응답은 테스트 데이터와 기대되는 동작의 명세라는 이중 역할을 한다 
  - 프로바이더 테스트 : 테스트 클래스가 계약의 요청을 프로바이더 서비스에 넘겨 호출하고 실제로 프로바이더가 계약에 맞게 응답을 반환하는지 확인한다
  - 컨슈머 테스트 : 계약으로 모키토의 목 객체와 유사한 스텁을 구성해서 프로바이더 서비스 동작을 시뮬레이션하여 프로바이더 서비스를 실행하지 않아도 테스트를 가능하게 한다
- 도메인 이벤트 발행 계약
  - 샘플 도메인 이벤트로 구성됨
  - 프로바이더 테스트 : 프로바이더가 이벤트를 발생시키도록 만들고 그것이 계약의 이벤트와 일치하는지 확인
  - 컨슈머 테스트 : 이벤트를 컨슈머가 처리할 수 있는 지 확인
- 비동기 요청 / 응답 계약
  - HTTP 계약과 비슷하게 요청 / 응답 메시지로 구성
  - 프로바이더 테스트 : 계약의 요청 메시지를 API에 넘겨 호출하고, 그 결과 반환된 응답이 계약의 응답과 일치하는지 확인
  - 컨슈머 테스트 : 계약을 이용하여 스텁 구독기를 구성하고, 이 스텁 구독기는 계약의 요청 메시지를 리스닝하다가 주어진 응답을 반환함


### **배포 파이프라인**
- 개발자가 데스크톱에서 작성한 코드를 프로덕션에 반영하는 자동화 프로세스
- 보통 젠킨스 같은 CI Continuous Integration 서버로 구축하여 각종 테스트를 실행하며, 완전 자동화가 이상적이지만 일부는 수작업으로 이루어진다
- 테스트 스위트 실행 단계, 서비스 릴리스/배포 단계 순서로 구성된다
  - 사전-커밋 pre-commit 테스트 단계 : 단위 테스트를 실행 (개발자가 변경분을 커밋하기 전에 수행하므로 배포 파이프라인에 속하지 않음)
  - 커밋 테스트 commit test 단계 : 서비스 컴파일 후 단위 테스트를 실행하고 정적 코드 분석을 수행
  - 통합 테스트 integration test 단계 : 통합 테스트를 실행
  - 컴포넌트 테스트 component test 단계 : 서비스 컴포넌트 테스트를 실행
  - 배포 deploy 단계 : 프로덕션에 서비스를 배포
  - cf. CI 서버는 개발자가 변경분을 커밋하는 즉시 커밋 테스트 단계를 실행하므로 피드백이 아주 빠르다
- 코드가 파이프라인을 흘러갈수록 테스트 스위트는 점점 더 프로덕션과 유사하면서 엄격한 테스트 환경에 종속되어 실행 시간이 증가한다
- 테스트가 모두 성공하면 파이프라인은 최종 단계에서 변경분을 프로덕션에 배포한다


* * *


## **단위 테스트**


### **단위 테스트 개요**
- 서비스의 아주 작은 부속품인 단위 unit 가 제대로 동작하는지 확인하는 테스트
- 일반적으로 단위는 클래스이므로 단위 테스트는 클래스가 예상대로 동작하는지 확인하는 것이 목표임
- 단위 테스트 종류
  - 독립 solitary 단위 테스트 : 클래스 디펜던시를 목 객체로 나타내고 클래스를 따로 테스트함
  - 공동 sociable 단위 테스트 : 클래스와 디펜던시를 함께 테스트함
- 클래스의 책임과 아키텍처에서의 역할마다 수행하는 단위 테스트 종류가 다르지만, 일반적으로 컨트롤러와 서비스는 독립 단위 테스트, 엔터티와 밸류 객체 같은 도메인 객체는 공동 단위 테스트를 사용한다
  - 영속적으로 식별 가능한 엔터티는 공동 단위 테스트를 수행
  - 값을 모아 놓은 밸류 객체는 공동 단위 테스트를 수행
  - 여러 서비스에 걸쳐 데이터 일관성을 유지하는 사가는 공동 단위 테스트를 수행
  - 비즈니스 로직을 구현한 도메인 서비스는 독립 단위 테스트를 수행
  - HTTP 요청을 처리하는 컨트롤러는 독립 단위 테스트를 수행
  - 인바운드 / 아웃바운드 메시징 게이트웨이는 독립 단위 테스트를 수행
- 단위 테스트로는 서비스가 올바르게 상호 작용하는지 확인할 수 없으므로 통합 테스트를 실행해야 하고, 컴포넌트 테스트가 필요한 경우도 있다


### **엔터티 테스트**
- 비즈니스 로직을 빈틈없이 테스트하는 공동 단위 테스트로 실행이 매우 빨라서 컴파일 타임 테스트로 사용 가능함
- 테스트 순서
  - 각 테스트를 실행하기 전에 @Before setUp()에서 필요한 엔터티를 생성한다
  - @Test 메서드는 엔터티를 초기화한 후 엔터티 메서드 중 하나를 호출해서 수신한 반환값과 엔터티 상태를 단언한다


### **밸류 객체 테스트**
- 밸류 객체는 불변이고 부수 효과 side-effect 를 걱정할 필요가 없기 때문에 테스트가 쉽다
- 의존하는 클래스가 전혀 없는 경우 독립 단위 테스트로 수행할 수 있다
- 테스트 순서
  - 주어진 상태로 밸류 객체를 생성한 후, 이 객체의 메서드 하나를 호출해서 수신한 값을 단언한다

### **사가 테스트**
- 사가는 사가 참여자에게 커맨드 메시지를 보내고 이들의 응답을 처리하는 영속적 객체로 중요한 비즈니스 로직이 구현되어 있어 반드시 테스트 해야한다
- 실제 DB와 메시지 브로커를 스텁과 함께 사용해서 테스트를 작성하면 느리기 때문에 DB, 메시지 브로커와 상호 작용하는 클래스를 모킹 mocking 한 테스트를 작성하여 사가와 그 디펜던시를 공동 단위 테스트한다 
- 테스트 순서
  - 사가를 생성하고 사가가 참여자에게 기대한 순서대로 메시지를 전송하는지 확인한다
  - 사가 참여자가 실패 메시지를 반환해서 사가가 롤백되는 다양한 시나리오에 대해서도 테스트를 작성해야 한다


### **도메인 서비스 테스트**
- 서비스 비즈니스 로직은 대부분 엔터티, 밸류 객체, 사가로 구현하고, 엔터티와 리포지터리를 호출하며 도메인 이벤트를 발행하는 등의 나머지를 도메인 서비스 클래스로 구현한다
- 리포지터리 및 메시징 클래스 같은 디펜던시를 모킹한 독립 단위 테스트를 수행한다
- 테스트 순서
  - 설정 : 서비스 디펜던시의 목 객체를 구성한다
  - 실행 : 서비스 메서드를 호출한다
  - 확인 : 서비스 메서드가 올바른 값을 반환하고 디펜던시가 올바르게 호출되었는지 확인한다


### **컨트롤러 테스트**
- 컨트롤러는 다른 서비스 및 API 게이트웨이에서 들어온 HTTP 요청을 처리하는 클래스로 각각 지정된 REST API endpoint 를 담당한 여러 메서드로 구성된다
- 컨트롤러 메서드는 경로 변수 path variable 처럼 HTTP 요청에서 추출된 값을 나타낸 매개변수를 받고, 도메인 서비스 또는 리포지터리를 호출해서 그 응답 객체를 반환한다
- 서비스와 리포지터리를 모킹한 독립 단위 테스트를 수행하며 요청 라우팅 같은 중요한 기능을 테스트하기 위해서 목 MVC 테스트 프레임워크를 활용한다
- 목 MVC 테스트 프레임워크
  - 스프링 목 MVC 또는 이를 기반으로 구축된 레스트 어슈어드 목 Rest Assured Mock MVC 등의 프레임워크
  - HTTP 요청을 보내서 반환된 HTTP 응답을 단언할 수 있기 때문에 네트워크 호출을 하지 않아도 HTTP 요청 라우팅 및 자바 객체 / JSON 변환이 가능하다
  - 외부 서블릿 컨테이너 out-of-servlet-container 통합 테스트 라고도 한다  
- 테스트 순서
  - 서비스와 리포지터리의 모키토 목이 주입된 컨트롤러를 생성한다
  - 테스트 메서드는 목을 구성한 후 HTTP 요청을 전송하고 그 응답이 정확한지 확인한다
  - 필요하다면 컨트롤러가 정말 목을 호출했는지도 확인한다


### **이벤트/메시지 핸들러 테스트**
- 메시지 어댑터는 다른 서비스가 발행한 도메인 이벤트 / 메시지를 처리하는 클래스로 컨트롤러처럼 도메인 서비스를 호출하는 단순 클래스이다
- 메시지 어댑터의 각 메서드는 메시지 / 이벤트에서 꺼낸 데이터를 서비스 메서드에 넘겨 호출한다
- 테스트 순서
  - 컨트롤러와 비슷한 방법으로 테스트별로 메시지 어댑터 인스턴스를 생성하고 메시지를 채널에 전송한 후, 서비스 목이 정확히 호출되었는지 확인하는 흐름으로 단위 테스트한다