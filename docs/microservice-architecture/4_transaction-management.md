---
layout: default
title: Transaction Management
parent: Micro Service Architecture Pattern
nav_order: 4
---

# Transaction Management
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **MSA 의 트랜잭션 관리**

### **분산 트랜잭션**
- 여러 서비스, DB, 메시지 브로커에 걸친 데이터 일관성을 유지하는 방식의 하나
- 모놀리식 애플리케이션에서는 ACID 트랜잭션으로 데이터를 배타적으로 접근해서 처리하여 데이터 일관성을 보장
- X/Open DTP 모델(X/Open XA) 
 - 2단계 커밋 2PC 을 이용하여 전체 트랜잭션 참여자가 반드시 커밋 아니면 롤백을 하도록 보장
 - XA 기술 스택 : XA 호환 DB, 메시지 브로커, DB 드라이버, 메시징 API, XA 전역 트랜잭션 ID를 전파하는 프로세스 간 매커니즘으로 구성
 - SQL DB는 대부분 XA와 호환
 - 자바 EE 애플리케이션은 JTA 기술을 이용하여 분산 트랜잭션을 수행
- 분산 트랜잭션의 문제점
 - NoSQL DB 와 최근 메시지 브로커(RabbitMQ, 아파치 카프카)는 분산 트랜잭션을 지원하지 않음
 - 동기 IPC 형태라서 가용성이 떨어짐
 - 요즘은 일관성보다 가용성을 더 우선시하는 편이어서 느슨하게 결합된 비동기 서비스 개념을 토대로 데이터 일관성을 유지하는 매커니즘이 필요

### **사가 패턴 : 데이터 일관성 유지**
- 사가 
  - 비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션
  - 여러 서비스의 데이터를 업데이트하는 시스템 작업마다 사가를 하나씩 정의
  - 시스템 작업은 사가의 첫 번째 로컬 트랜잭션을 시작하고 각 로컬 트랜잭션은 ACID 트랜잭션으로 서비스별 데이터를 업데이트
  - 로컬 트랜잭션이 완료되면 메시지를 발행하여 그 다음 로컬 트랜잭션을 트리거
  - 비동기 메시징은 하나 이상의 사가 참여자가 일시 불능 상태인 경우에도 사가의 전체 단계를 확실히 실행시킬 수 있게 함
- 보상 트랜잭션 compensating transaction 
  - 로컬 트랜잭션이 실패하는 경우 앞서 진행된 로컬 트랜잭션을 명시적으로 언두하는 트랜잭션
  - 사가는 단계마다 로컬 DB에 변경분을 커밋하므로 자동 롤백이 불가능하여 보상 트랜잭션이 필요함
  - 사가는 특정 단계에서 트랜잭션이 실패하면 트랜잭션이 진행하는 반대 반향으로 보상 트랜잭션을 실행
  - 읽기 전용 read-only 단계나 다음 단계가 항상 성공하는 단계는 보상 트랜잭션이 필요 없음
- 사가의 구조
  - 보상 가능 트랜잭션 compensatable transaction : 보상 트랜잭션으로 롤백 가능한 트랜잭션
  - 피봇 트랜잭션 pivot transaction : 사가의 진행 / 중단 지점. 피봇 트랜잭션이 커밋되면 사가는 완료될 때까지 실행됨. 최종 보상 가능 트랜잭션 또는 최초 재시도 가능 트랜잭션이 될 수 있음
  - 재시도 가능 트랜잭션 retriable transaction : 피봇 트랜잭션 이후 트랜잭션. 반드시 성공함


* * *


## **사가 편성 로직**


### **코레오그래피 choreography 사가**
- 중앙 편성자 없이 의사 결정과 순서화를 사가 참여자에 맡기는 방식
- 사가 참여자는 서로 이벤트 발행 / 구독 방식으로 통신
- 각 참여자는 자신의 DB를 업데이트하고 다음 참여자를 트리거하는 이벤트를 발행
  - DB를 업데이트하는 작업과 이벤트를 발행하는 작업이 원자적으로 atomically 일어나야 하므로 트랜잭셔널 메시징을 사용해야 함
  - 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관 지을 수 있어야 하므로 상관관계 ID 가 포함된 이벤트를 발행해야 함
- 코레오그래피 사가의 장점
  - 단순함 : 비즈니스 객체를 생성, 수정, 삭제할 때 서비스가 이벤트를 발행하면 됨
  - 느슨한 결합 : 참여자는 이벤트를 구독할 뿐 서로 직접 알지 못함
- 코레오그래피 사가의 단점
  - 이해하기 어렵다 : 여러 서비스에 구현 로직이 흩어져 있어서 사가가 어떻게 작동되는지 개발자가 이해하기 어려운 편이다
  - 서비스 간 순환 의존성 : 참여자가 서로 이벤트를 구독하는 특성상 순환 의존성이 발생하기 쉽다
  - 단단히 결합될 위험성 : 사가 참여자는 자신에게 영향을 미치는 이벤트를 모두 구독해야 한다


### **오케스트레이션 orchestration 사가**
- 사가 참여자에게 커맨드 메시지를 보내 수행할 작업을 지시하는 사가 오케스트레이터에 사가 편성 로직을 중앙화하는 방식
- 사가 오케스트레이터는 커맨드 / 비동기 응답 상호 작용을 하며 사가 참여자와 통신
- 사가 오케스트레이터가 사가 참여자에게 커맨드 메시지를 보내면 사가 참여자는 작업을 마치고 응답 메시지를 오케스트레이터에게 주고, 오케스트레이터는 응답 메시지를 처리한 후 다음 사가 단계를 어느 참여자가 수행할 지 결정
- 상태 기계 state machine 모델
  - 상태 state 와 이벤트에 의해 트리거되는 상태 전이 transition 로 구성된 모델로 전이가 발생할 때마다 액션 action 이 일어남
  - 상태 기계를 이용하여 사가를 모델링하면 설계, 구현, 테스트를 쉽게 진행할 수 있음
  - 사가에서 상태 전이는 사가 참여자가 로컬 트랜잭션을 완료하는 시점에 트리거되고, 로컬 트랜잭션의 상태와 결과에 따라 상태 전이 값과 사가 참여자를 호출하는 액션이 결정됨
  - 상태 기계는 사가 참여자의 여러 가지 응답에 따라 다양한 상태 전이를 거치면서 최종 상태로 귀결됨
- 오케스트레이션 사가는 트랜잭셔널 메시징을 사용해 DB를 업데이트하고 메시지를 발행하는 작업을 단계마다 원자적으로 처리
- 오케스트레이션 사가의 장단점
  - 의존 관계 단순화 : 오케스트레이터만 참여자를 호출하고 참여자는 오케스트레이터를 호출하지 않으므로 순환 의존성이 발생하지 않음
  - 낮은 결합도 : 각 서비스는 API만 구현할 뿐, 다른 사가 참여자가 발행하는 이벤트는 몰라도 된다
  - 관심사 분리 및 비즈니스 로직 단순화 : 사가 편성 로직이 사가 오케스트레이터 한곳에만 있으므로 각 도메인 객체의 상태는 단순해짐 (각 도메인 객체가 사가 단계에 대응하는 모든 상태를 가질 필요가 없음)
  - 비즈니스 로직이 오케스트레이터에 너무 많이 중앙화될 수 있으므로 오케스트레이터는 순서화만 담당하고 비즈니스 로직은 갖고 있지 않도록 설계해야 함


* * *


## **비격리 문제 처리**


### **사가 패턴의 트랜잭션 특징과 이로 인한 문제점**
- 사가는 트랜잭션 속성 중 ACD만 지원함
  - 원자성 Atomicity :  사가는 트랜잭션을 모두 완료하거나 모든 변경분을 언두 해야 한다
  - 일관성 Consistency : 서비스 내부의 참조 무결성 referential integrity은 로컬 DB가, 여러 서비스에 걸친 참조 무결성은 서비스가 처리한다
  - 지속성 Durability : 로컬 DB로 처리한다
- 사가는 사가의 한 트랜잭션이 커밋한 변경분을 다른 사가가 즉시 바라볼 수 있어서 격리성이 보장되지 않는다
  - 한 사가가 실행 중에 접근하는 데이터를 도중에 다른 사가가 바꿔치기할 수 있다
  - 한 사가가 업데이트를 하기 이전 데이터를 다른 사가가 읽을 수 있어서 데이터 일관성이 깨질 수 있다
  - 동시에 실행 중인 여러 트랜잭션의 결과가 순서대로 실행된 결과와 동일하지 않을 수 있다


### **비격리로 인한 비정상**
- 소실된 업데이트 lost update : 한 사가의 변경분을 다른 사가가 미처 못 읽고 덮어 쓰는 문제
- 더티 읽기 dirty reads : 한 사가가 업데이트 중인 데이터를 다른 트랜잭션이나 사가가 읽는 문제
- 퍼지 / 반복 불가능한 읽기 fuzzy / nonrepeatable reads : 한 사가의 상이한 두 단계가 같은 데이터를 읽었는데 결과가 달라지는 현상. 다른 사가가 그 사이 업데이트를 했을 때 발생


### **비격리 대책**
- 시맨틱 락 semantic lock 
  - 애플리케이션 수준의 락으로 보상 가능 트랜잭션이 생성 / 수정하는 레코드에 무조건 플래그를 세팅하는 방식 ex. *_PENDING 상태를 사용
  - 플래그는 다른 트랜잭션이 접근하지 못하게 락 lock 을 걸거나 다른 트랜잭션이 해당 레코드를 처리할 때 조심하도록 경고 warning 하는 역할을 하며 재시도 가능 트랙잭션 또는 보상 트랜잭션에 의해 해제됨
  - 다른 트랜잭션이 잠금된 레코드에 접근 시 실패 처리하고 재시도 로직을 구현하거나 잠금이 해제될 때까지 블로킹 처리
  - 데드락 deadlock 감지 알고리즘을 구현해서 데드락이 발생하면 사가를 롤백시켜 데드락을 해소하고 재실행할 수 있게 조치해야 함 
- 교환적 업데이트 commutative updates
  - 업데이트 작업을 어떤 순서로 실행해도 되게끔 설계해서 소실된 업데이트 문제를 방지
  - 보상 가능 트랜잭션과 보상 트랜잭션이 서로 교환적인 작업이 되도록 설계함 ex. debit 과 credit 
- 비관적 관점 pessimistic view
  - 사가 단계 순서를 재조정하여 더티 읽기로 인한 비즈니스 리스크를 최소화
  - 더티 읽기의 대상이 될 위험이 있는 트랜잭션을 재시도 가능 트랜잭션으로 처리
- 값 다시 읽기 reread value 
  - 데이터를 덮어 쓸 때 그 전에 변경된 내용은 없는지 값을 다시 읽고 확인하여 소실된 업데이트를 방지
  - 값이 변경되었다면 사가를 중단하고 보상 트랜잭션을 진행
  - 일종의 낙관적 오프라인 락 Optimistic Offline Lock 패턴
  - cf. 낙관적 잠금 : 버전 VERSION 컬럼을 이용하여 마지막으로 데이터를 읽은 이후 변경되었는지 감지하여 다른 트랜잭션의 변경을 덮어쓰지 않도록 하는 방식. 업데이트될 때마다 버전 값을 하나 씩 증가시킴.

- 버전 파일 version file
  - 레코드에 수행한 작업을 하나하나 기록하는 방식으로 순서에 맞지 않는 요청이 도착하면 기록해 두었다가 정확한 순서대로 실행
  - 비교환적 작업을 교환적 작업으로 변환하는 방법임
- 값에 의한 by value
  - 비즈니스 위험성을 기준으로 동시성 매커니즘을 동적 선택하는 방법
  - 위험성이 낮은 요청은 사가를 사용하고 위험성이 큰 요청은 분산 트랜잭션을 실행