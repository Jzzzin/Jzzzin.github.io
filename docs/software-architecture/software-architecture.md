---
layout: default
title: Software Architecture
parent: Software Architecture Index
nav_order: 1
---

# Software Architecture
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **소프트웨어 아키텍처**


### **소프트웨어 아키텍처의 정의**
- 소프트웨어 엘리먼트 element 와 그들 간의 관계, 그리고 이 둘의 속성 property 으로 구성된 시스템을 추론하는 데 필요한 구조 structure 의 집합
- 구성 요소 및 그들 간의 디펜던시 dependency 로 엮인 고수준의 구조물
- 소프트웨어의 품질 속성 지표(확장성, 신뢰성, 관리성, 테스트성, 배포성 등)를 결정
- 업무 labor 와 지식 knowledge 을 분리하여 전문 지식을 보유한 사람들이 함께 협업할 수 있게 함


### **4+1 뷰 모델**
- 논리 뷰 logical view : 개발자가 작성한 소프트웨어 / 엘리먼트(클래스, 패키지 등) / 관계(상속 inheritance, 연관 association, 의존 depends-on 등)
- 구현 뷰 implementation view : 빌드 시스템의 결과물 / 엘리먼트(모듈 및 컴포넌트) / 관계(모듈 간 디펜던시, 컴포넌트 / 모듈 간 조합 관계)
- 프로세스 뷰 process view : 런타임 컴포넌트 / 엘리먼트(개별 프로세스) / 관계(프로세스 간 통신 IPC)
- 배포 뷰 deployment view : 프로세스가 머신에 매핑되는 방법 / 엘리먼트(머신 및 프로세스) / 관계(네트워킹)
- 시나리오 : 특정 뷰 내에서 아키텍처 요소가 협동하여 요청을 처리하는 방법을 기술


### **아키텍처의 중요성**
- 애플리케이션 기능 요건은 아키텍처와 무관하게 구현 가능함
- 서비스 품질 요건은 아키텍처에 따라 얼마나 충족할 수 있을지 결정됨


* * *


## **아키텍처 스타일**


### **아키텍처 스타일의 정의**
- 체계적인 조직의 관점에서 시스템 군을 정의
- 특정 아키텍처 스타일로 만든 인스턴스에서 사용 가능한 컴포넌트 와 커넥터 connector 의 보케블러리 vocabulary, 그리고 이들을 조합할 수 있는 제약 조건 constraint 을 결정
- 엘리먼트(컴포넌트) 와 관계(커넥터) 의 한정된 팔레트 palette(사용가능한 범위)를 제공


### **계층화 아키텍처 스타일 layered architecture**
- 소프트웨어 엘리먼트를 계층별로 구성
- 계층마다 명확히 정의된 역할을 분담하며, 계층 간 디펜던시는 아키텍처로 제한하여 하위에 있는 계층만 의존
- 3계층 아키텍처 : 표현 계층 presentation layer, 비즈니스 로직 계층 business logic layer, 영속화 계층 persistence layer
- 표현 계층 및 영속화 계층이 하나 뿐인 단점이 있고, 비즈니스 로직 계층이 영속화 계층에 의존하는 형태로 정의되어 DB 없이 비즈니스 로직을 테스트하는 것이 불가능함


### **육각형 아키텍처 스타일**
- 표현 계층 대신 인바운드 포트와 어댑터, 영속화 계층 대신 아웃바운드 포트와 어댑터를 두는 계층화 아키텍처 스타일의 대안
- 인바운드 포트 : 비즈니스 로직이 표출된 API ex.서비스 인터페이스 등
- 인바운드 어댑터 : 인바운트 포트로 비즈니스 로직을 호출해서 외부 요청을 처리 ex. REST endpoint, MVC 컨트롤러, 메시지 컨슈머 등
- 아웃바운드 포트 : 비즈니스 로직이 외부 시스템을 호출하는 방법이 정의된 작업 ex. 리포지터리 인터페이스, 메시징 인터페이스 등
- 아웃바운드 어댑터 : 비즈니스 로직에 들어온 요청을 외부 애플리케이션 / 서비스를 호출해서 처리 ex. 데이터 접근 객체 DAO 클래스, 원격 서비스 호출 proxy 클래스, 메시지 프로듀서 등
- 비즈니스 로직에 있던 표현 / 데이터 접근 로직이 어댑터와 분리되어 비즈니스 로직이 표현 / 데이터 접근 로직 어디에도 의존하지 않음


* * *


## **마이크로서비스 아키텍처**


### **서비스**
- 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트
- 클라이언트에게 커맨드 command (명령, CUD), 쿼리 query (조회, R), 이벤트 event 로 구성된 API를 제공
- 서비스 API는 내부 구현 상세를 캡슐화하여 모듈성을 보장
- 논리 뷰는 대부분 육각형 아키텍처 형태를 취함
- 구현 뷰는 다양한 컴포넌트를 사용할 수 있음


### **느슨한 결합**
- 서비스는 API를 통해서만 상호작용하므로 클라이언트에 영향을 끼치지 않고 서비스 내부 구현 코드를 변경 가능
- 유지보수성, 테스트성을 높이고 개발시간이 단축됨
- 서비스의 영속적 데이터는 반드시 프라이빗으로 유지함
- 런타임 격리가 향상되지만 일관성을 유지하는 일은 더 복잡해짐


### **공유 라이브러리의 역할**
- 서비스 간 의도치 않은 결합도를 유발하지 않도록 조심해야 함
- 변경 가능성이 조금이라도 있는 기능은 별도의 서비스로 구현
- 바뀔 일이 거의 없는 기능은 공유 라이브러리로 사용


### **서비스의 규모**
- 크기가 중요한 것이 아니다
- 작은 팀이 가장 짧은 시간에, 다른 팀과 협동하는 부분은 최소로 하여 개발 가능한 서비스를 설계
- 대규모 팀을 꾸려야 하거나 테스트 시간이 너무 오래 걸리면 팀과 서비스를 분할해야 함
- 다른 서비스의 변경에 영향을 받거나 내 서비스 때문에 다른 서비스가 바뀌어야 한다면 느슨하게 결합되지 않은 것
